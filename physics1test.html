<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Physics 1 2023 FRQ</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: url('images/bgg.gif') no-repeat center center fixed;
            background-size: cover;
            font-family: Arial, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .content {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 40px;
            margin: 40px;
            border-radius: 10px;
            max-width: 800px;
            width: 90%;
        }
        .page {
            display: none;
        }
        .page.active {
            display: block;
        }
        .navigation {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 20px;
            background-color: rgba(0, 0, 32, 0.4);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        .nav-button {
            background-color: rgba(0, 0, 128, 0.3);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .nav-button:hover {
            background-color: rgba(0, 0, 128, 0.5);
        }
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 128, 0.6);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            text-decoration: none;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: rgba(0, 0, 128, 0.8);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .page-number {
            color: white;
            margin: 0 20px;
        }
        .question-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #000;
            border-radius: 5px;
        }
        .question-text {
            margin-bottom: 20px;
        }
        .sub-question {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .math {
            font-style: italic;
        }
        .data-table {
            margin: 20px 0;
            overflow-x: auto;
        }
        .data-table table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px;
            text-align: center;
        }
        .data-table th {
            background-color: rgba(0, 0, 128, 0.3);
        }
        .data-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .answer-space {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            min-height: 120px;
            margin: 15px 0;
            padding: 10px;
            width: 100%;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
        }
        .answer-space:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background-color: rgba(255, 255, 255, 0.15);
        }
        .short-answer-space {
            min-height: 80px;
        }
        .long-answer-space {
            min-height: 150px;
        }
        .graph-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
        }
        .graph-box {
            flex: 1;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 10px;
        }
        .graph-title {
            text-align: center;
            color: black;
            margin-bottom: 10px;
        }
        canvas {
            background-color: white;
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        .graph-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .graph-button {
            background-color: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .graph-button:hover {
            background-color: #444;
        }
        .grid-graph-container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .grid-canvas {
            background-color: white;
            border: 1px solid #000;
        }
        .force-diagram-container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .force-diagram {
            background-color: white;
            border: 1px solid #000;
        }
        .diagram-label {
            text-align: center;
            color: black;
            margin-top: 5px;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }
        .modal-content {
            background-color: rgba(0, 0, 32, 0.95);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            color: white;
        }
        .modal-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 10px;
        }
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: rgba(0, 0, 128, 0.5);
            color: white;
            transition: background-color 0.3s;
        }
        .modal-button:hover {
            background-color: rgba(0, 0, 128, 0.8);
        }
        #submitAnonymous {
            background-color: #666;
        }
        #submitWithName {
            background-color: #004d00;
        }
        #cancelSubmit {
            background-color: #660000;
        }
        .test-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .test-item {
            background-color: rgba(0, 0, 128, 0.3);
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .test-item:hover {
            background-color: rgba(0, 0, 128, 0.5);
        }
        .test-item h4 {
            margin: 0 0 10px 0;
        }
        .test-item p {
            margin: 0;
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <a href="physics1.html" class="back-button">Back</a>
    
    <div class="content">
        <div class="page active" id="page1">
            <h1>AP Physics 1 2023 Free-Response Questions</h1>
            <h2>Section II</h2>
            <h3>Time—1 hour and 30 minutes</h3>
            <h3>5 Questions</h3>
            <br>
            <h3>Directions:</h3>
            <p>Questions 1, 4, and 5 are short free-response questions that require about 13 minutes each to answer and are worth 7 points each. Questions 2 and 3 are long free-response questions that require about 25 minutes each to answer and are worth 12 points each. Show your work for each part in the space provided after that part.</p>
        </div>
        
        <div class="page" id="page2">
            <h2>Question 1 (7 points)</h2>
            <div class="question-text">
                <p>A cart on a horizontal surface is attached to a spring. The other end of the spring is attached to a wall. The cart is initially held at rest, as shown in Figure 1. When the cart is released, the system consisting of the cart and spring oscillates between the positions <span class="math">x = +L</span> and <span class="math">x = -L</span>. Figure 2 shows the kinetic energy of the cart-spring system as a function of the system's potential energy. Frictional forces are negligible.</p>
            </div>
            <img src="images/image1.png" alt="Physics problem diagram" class="question-image">
            <div class="sub-question">
                <p>(a) On the graph of kinetic energy <span class="math">K</span> versus potential energy <span class="math">U</span> shown in Figure 2, the values for the <span class="math">x</span>-intercept and <span class="math">y</span>-intercept are the same. Briefly explain why this is true, using physics principles.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) When the cart is at <span class="math">+L</span> and momentarily at rest, a block is dropped onto the cart, as shown in Figure 3. The block sticks to the cart, and the block-cart-spring system continues to oscillate between <span class="math">-L</span> and <span class="math">+L</span>. The masses of the cart and the block are <span class="math">m₀</span> and <span class="math">3m₀</span>, respectively. The frequency of oscillation before the block is dropped onto the cart is <span class="math">f₁</span>. The frequency of oscillation after the block is dropped onto the cart is <span class="math">f₂</span>. Calculate the numerical value of the ratio <span class="math">f₂/f₁</span>.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) The dashed line in Figure 4 shows the kinetic energy <span class="math">K</span> versus potential energy <span class="math">U</span> of the block-cart-spring system after the block is dropped onto the cart. This graph is identical to the graph shown in Figure 2 for the cart-spring system before the block is dropped onto the cart.</p>
                <p>i. Briefly explain why the two graphs must be the same, using physics principles.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. After the block is dropped onto the cart, consider a system that consists only of the cart and the spring. On Figure 4, sketch a solid line that shows the kinetic energy of the system that consists of the cart and the spring but not the block after the block is dropped onto the cart.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page3">
            <h2>Question 2 (12 points)</h2>
            <div class="question-text">
                <p>Students conduct an experiment to determine the acceleration <span class="math">a</span> of a cart. The cart is released from rest at the top of the ramp at time <span class="math">t = 0</span> and moves down the ramp. The <span class="math">x</span>-axis is defined to be parallel to the ramp with its origin at the top, as shown in the figure. The students collect the data shown in the following table.</p>
            </div>
            <img src="images/image2.png" alt="Physics problem diagram" class="question-image">
            <div class="data-table">
                <table>
                    <tr>
                        <th>Position <span class="math">x</span> (m)</th>
                        <th>Time <span class="math">t</span> (s)</th>
                    </tr>
                    <tr><td>0.06</td><td>0.39</td></tr>
                    <tr><td>0.14</td><td>0.59</td></tr>
                    <tr><td>0.24</td><td>0.77</td></tr>
                    <tr><td>0.37</td><td>0.96</td></tr>
                    <tr><td>0.55</td><td>1.20</td></tr>
                </table>
            </div>
            <div class="sub-question">
                <p>(a)</p>
                <p>i. Indicate which quantities could be graphed to yield a straight line whose slope could be used to determine the acceleration <span class="math">a</span> of the cart. You may use the remaining columns in the table, as needed, to record any quantities (including units) that are not already in the table.</p>
                <p>Vertical axis: Horizontal axis: </p>
                <textarea class="answer-space short-answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. On the following grid, plot the appropriate quantities to create a graph that can be used to determine the acceleration <span class="math">a</span> of the cart as it rolls down the ramp. Clearly scale and label all axes (including units), as appropriate. Draw a straight line that best represents the data.</p>
                <div class="grid-graph-container">
                    <canvas id="gridGraph" width="500" height="400" class="grid-canvas"></canvas>
                    <div class="graph-controls">
                        <button class="graph-button" onclick="clearGridCanvas()">Clear</button>
                        <button class="graph-button" onclick="undoGridStroke()">Undo</button>
                    </div>
                </div>
                <p>iii. Using the line you drew in part (a)(ii), calculate an experimental value for the acceleration <span class="math">a</span> of the cart as it rolls down the ramp.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) The students are asked to determine an experimental value for the acceleration due to gravity <span class="math">g<sub>exp</sub></span> using their data.</p>
                <p>i. What additional quantities do the students need to measure in order to calculate <span class="math">g<sub>exp</sub></span> from <span class="math">a</span>?</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Write an expression for the value of <span class="math">g<sub>exp</sub></span> in terms of <span class="math">a</span>.</p>
                <textarea class="answer-space short-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) The students calculate the value of <span class="math">g<sub>exp</sub></span> to be significantly lower than the accepted value of 9.8 m/s².</p>
                <p>i. What is a physical reason, other than friction or air resistance, that could lead to a significant difference in the experimentally determined value of <span class="math">g<sub>exp</sub></span>?</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Briefly explain how the physical reason you identified in part (c)(i) would lead to the decrease in the experimentally determined value of <span class="math">g<sub>exp</sub></span>.</p>
                <img src="images/image3.png" alt="Physics problem diagram" class="question-image">
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(d) The students want to confirm that the acceleration is the same whether the cart rolls up or down the ramp. The students start the cart at the bottom and give the cart a quick push so that it rolls up the ramp and momentarily comes to rest. The <span class="math">x</span>-axis is still defined to be parallel to the ramp with the origin at the top.</p>
                <p>On the following graphs, sketch the position <span class="math">x</span> and velocity <span class="math">v</span> as functions of time <span class="math">t</span> that correspond to the scenario shown while the cart moves up the ramp.</p>
                <div class="graph-container">
                    <div class="graph-box">
                        <div class="graph-title">Position vs. Time</div>
                        <canvas id="positionGraph" width="350" height="350"></canvas>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearCanvas('positionGraph')">Clear</button>
                            <button class="graph-button" onclick="undoLastStroke('positionGraph')">Undo</button>
                        </div>
                    </div>
                    <div class="graph-box">
                        <div class="graph-title">Velocity vs. Time</div>
                        <canvas id="velocityGraph" width="350" height="350"></canvas>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearCanvas('velocityGraph')">Clear</button>
                            <button class="graph-button" onclick="undoLastStroke('velocityGraph')">Undo</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="page" id="page4">
            <h2>Question 3 (12 points)</h2>
            <img src="images/image6.png" alt="Physics problem diagram" class="question-image">
            <div class="question-text">
                <p>A small block of mass <span class="math">m₀</span> is attached to the end of a spring of spring constant <span class="math">k₀</span> that is attached to a rod on a horizontal table. The rod is attached to a motor so that the rod can rotate at various speeds about its axis. When the rod is not rotating, the block is at rest and the spring is at its unstretched length <span class="math">L</span>, as shown. All frictional forces are negligible.</p>
            </div>
            <img src="images/image7.png" alt="Physics problem diagram showing Figure 1 and Figure 2" class="question-image">
            <div class="sub-question">
                <p>(a) At time <span class="math">t = t₁</span>, the rod is spinning such that the block moves in a circular path with a constant tangential speed <span class="math">v₁</span> and the spring is stretched a distance <span class="math">d₁</span> from the spring's unstretched length, as shown in Figure 1. At time <span class="math">t = t₂</span>, the rod is spinning such that the block moves in a circular path with a constant tangential speed <span class="math">v₂</span> and the spring is stretched a distance <span class="math">d₂</span> from the spring's unstretched length, where <span class="math">d₂ > d₁</span>, as shown in Figure 2.</p>
                <p>i. On the following dots, which represent the block at the locations shown in Figure 1 and Figure 2, draw the force that is exerted on the block by the spring at times <span class="math">t = t₁</span> and <span class="math">t = t₂</span>. The spring force must be represented by a distinct arrow starting on, and pointing away from, the dot.</p>
                <p><em>Note: Draw the relative lengths of the vectors to reflect the relative magnitudes of the forces exerted by the spring at both times.</em></p>
                <div class="force-diagram-container">
                    <div>
                        <canvas id="forceT1" width="200" height="200" class="force-diagram"></canvas>
                        <div class="diagram-label">t = t₁</div>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearForceDiagram('forceT1')">Clear</button>
                            <button class="graph-button" onclick="undoForceStroke('forceT1')">Undo</button>
                        </div>
                    </div>
                    <div>
                        <canvas id="forceT2" width="200" height="200" class="force-diagram"></canvas>
                        <div class="diagram-label">t = t₂</div>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearForceDiagram('forceT2')">Clear</button>
                            <button class="graph-button" onclick="undoForceStroke('forceT2')">Undo</button>
                        </div>
                    </div>
                </div>
                <p>ii. Referencing <span class="math">d₁</span> and <span class="math">d₂</span>, describe your reasoning for drawing the arrows the length that you did in part (a)(i).</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <img src="images/image10.png" alt="Physics problem diagram showing Figure 3" class="question-image">
                <p>iii. Is the tangential speed <span class="math">v₁</span> of the block at time <span class="math">t = t₁</span> greater than, less than, or equal to the tangential speed <span class="math">v₂</span> of the block at time <span class="math">t = t₂</span>?</p>
                <p>Justify your answer without using equations.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) Consider a scenario where the block travels in a circular path where the spring is stretched a distance <span class="math">d</span> from its unstretched length <span class="math">L</span>.</p>
                <p>i. Determine an expression for the magnitude of the net force <span class="math">F<sub>net</sub></span> exerted on the block. Express your answer in terms of <span class="math">m₀</span>, <span class="math">k₀</span>, <span class="math">L</span>, <span class="math">d</span>, and fundamental constants, as appropriate.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Derive an equation for the tangential speed <span class="math">v</span> of the block. Express your answer in terms of <span class="math">m₀</span>, <span class="math">k₀</span>, <span class="math">L</span>, <span class="math">d</span>, and fundamental constants, as appropriate.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) Does your equation for the tangential speed <span class="math">v</span> of the block from part (b)(ii) agree with your reasoning from part (a)?</p>
                <p>Explain your reasoning.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page5">
            <h2>Question 4 (7 points)</h2>
            <div class="question-text">
                <img src="images/image4.png" alt="Physics problem diagram" class="question-image">
                <p>A block of unknown mass is attached to a long, lightweight string that is wrapped several turns around a pulley mounted on a horizontal axis through its center, as shown. The pulley is a uniform solid disk of mass \(M\) and radius \(R\). The rotational inertia of the pulley is described by the equation \(I = \frac{1}{2}MR^2\). The pulley can rotate about its center with negligible friction. The string does not slip on the pulley as the block falls.</p>
                <p>When the block is released from rest and as the block travels toward the ground, the magnitude of the tension exerted on the block by the string is \(F_T\).</p>
            </div>
            <div class="sub-question">
                <p>(a) Determine an expression for the magnitude of the angular acceleration \(\alpha_D\) of the disk as the block travels downward. Express your answer in terms of \(M\), \(R\), \(F_T\), and physical constants as appropriate.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <img src="images/image5.png" alt="Physics problem diagram" class="question-image">
            </div>
            <div class="sub-question">
                <p>(b) Scenarios 1 and 2 show two different pulleys. In Scenario 1, the pulley is the same solid disk referenced in part (a). In Scenario 2, the pulley is a hoop that has the same mass \(M\) and radius \(R\) as the disk. Each pulley has a lightweight string wrapped around it several turns and is mounted on a horizontal axle, as shown. Each pulley is free to rotate about its center with negligible friction.</p>
                <p>In both scenarios, the pulleys begin at rest. Then both strings are pulled with the same constant force \(F_A\) for the same time interval \(\Delta t\), causing the pulleys to rotate without the string slipping. After time interval \(\Delta t\), the change in angular momentum of the disk is equal to the change in angular momentum of the hoop, but the change in rotational kinetic energy for the disk is greater than that of the hoop.</p>
                <p>In a clear, coherent paragraph-length response that may also contain equations and drawings, explain why the change in angular momentum of both pulleys is the same but the change in rotational kinetic energy is greater for the disk.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page6">
            <h2>Question 5 (7 points)</h2>
            <img src="images/image8.png" alt="Physics problem diagram showing rod-sphere system" class="question-image">
            <div class="question-text">
                <p>A rod with a sphere attached to the end is connected to a horizontal mounted axle and carefully balanced so that it rests in a position vertically upward from the axle. The center of mass of the rod-sphere system is indicated with a \(\otimes\), as shown in Figure 1. The sphere is lightly tapped, and the rod-sphere system rotates clockwise with negligible friction about the axle due to the gravitational force.</p>
                <p>A student takes a video of the rod rotating from the vertically upward position to the vertically downward position. Figure 2 shows five frames (still shots) that the student selected from the video. <em>Note: these frames are not equally spaced apart in time.</em></p>
            </div>
            <img src="images/image9.png" alt="Physics problem diagram showing video frames" class="question-image">
            <div class="sub-question">
                <p>(a) Use the frames of the video shown in Figure 2 to answer the following questions.</p>
                <p>i. In which frame is the angular acceleration of the rod-sphere system the greatest? Justify your answer.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. In which frame is the rotational kinetic energy of the rod-sphere system the greatest? Briefly justify your answer.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <img src="images/image10.png" alt="Physics problem diagram showing Figure 3" class="question-image">
            <div class="sub-question">
                <p>(b) The rod-sphere system has mass \(M\) and length \(L\), and the center of mass is located a distance \(\frac{3}{4}L\) from the axle, shown in Figure 3.</p>
                <p>i. Derive an expression for the change in kinetic energy of the rod-sphere-Earth system from the moment shown in Frame A to the moment shown in Frame E. Express your answer in terms of \(M\), \(L\), and fundamental constants, as appropriate.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Briefly explain why the rod and sphere gain kinetic energy, even if Earth is not included in the system.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>
    </div>

    <div class="navigation">
        <button class="nav-button" id="prevBtn">←</button>
        <span class="page-number">Page <span id="currentPage">1</span></span>
        <button class="nav-button" id="nextBtn">→</button>
        <button class="nav-button" id="submitBtn" style="background-color: #004d00;">Submit Test</button>
    </div>

    <!-- Submission Modal -->
    <div id="submissionModal" class="modal">
        <div class="modal-content">
            <h3>Submit Your Test</h3>
            <p>Please enter your name or choose to submit anonymously:</p>
            <input type="text" id="submitterName" placeholder="Your Name" class="modal-input">
            <div class="modal-buttons">
                <button id="submitAnonymous" class="modal-button">Submit Anonymously</button>
                <button id="submitWithName" class="modal-button">Submit with Name</button>
                <button id="cancelSubmit" class="modal-button">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Test Selection Modal -->
    <div id="testSelectionModal" class="modal">
        <div class="modal-content">
            <h3>Select a Test</h3>
            <div class="test-list">
                <div class="test-item" data-test="physics1test">
                    <h4>AP Physics 1 - 2023 FRQ</h4>
                    <p>Free Response Questions from the 2023 AP Physics 1 exam</p>
                </div>
                <!-- More tests can be added here -->
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1358211714021064734/xSnw0fEHm8pdGauYYtR3Y--tqXTzfTd5TUWj53LmVFgeasutHkvJuoeVDrTuLB_htkZa";
        
        let currentPageIndex = 1;
        const totalPages = 6;

        function updatePage() {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            document.getElementById(`page${currentPageIndex}`).classList.add('active');
            
            document.getElementById('currentPage').textContent = currentPageIndex;
            
            document.getElementById('prevBtn').disabled = currentPageIndex === 1;
            document.getElementById('nextBtn').disabled = currentPageIndex === totalPages;
        }

        document.getElementById('prevBtn').addEventListener('click', () => {
            if (currentPageIndex > 1) {
                currentPageIndex--;
                updatePage();
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (currentPageIndex < totalPages) {
                currentPageIndex++;
                updatePage();
            }
        });

        updatePage();

        const canvasStates = {
            positionGraph: [],
            velocityGraph: []
        };
        
        function initCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // Draw x-axis
            ctx.beginPath();
            ctx.moveTo(50, canvas.height/2);
            ctx.lineTo(canvas.width - 20, canvas.height/2);
            ctx.stroke();
            
            // Draw y-axis
            ctx.beginPath();
            ctx.moveTo(50, canvas.height - 20);
            ctx.lineTo(50, 20);
            ctx.stroke();
            
            // Add arrows
            ctx.beginPath();
            ctx.moveTo(canvas.width - 20, canvas.height/2);
            ctx.lineTo(canvas.width - 30, canvas.height/2 - 10);
            ctx.lineTo(canvas.width - 30, canvas.height/2 + 10);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(50, 20);
            ctx.lineTo(40, 30);
            ctx.lineTo(60, 30);
            ctx.fill();
            
            // Add labels
            ctx.font = '14px Arial';
            ctx.fillStyle = '#000';
            ctx.fillText('t', canvas.width - 20, canvas.height/2 + 20);
            ctx.fillText(canvasId === 'positionGraph' ? 'x' : 'v', 30, 30);
            ctx.fillText('O', 35, canvas.height/2 + 15);
            
            // Save initial state
            canvasStates[canvasId] = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            function startDrawing(e) {
                isDrawing = true;
                [lastX, lastY] = getMousePos(canvas, e);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const [currentX, currentY] = getMousePos(canvas, e);
                
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                [lastX, lastY] = [currentX, currentY];
            }
            
            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    canvasStates[canvasId].push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                }
            }
        }
        
        function getMousePos(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvasStates[canvasId] = [];
            initCanvas(canvasId);
        }
        
        function undoLastStroke(canvasId) {
            if (canvasStates[canvasId].length > 1) {
                canvasStates[canvasId].pop();
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                ctx.putImageData(canvasStates[canvasId][canvasStates[canvasId].length - 1], 0, 0);
            }
        }
        
        // Initialize both canvases when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
        });

        const gridCanvasStates = [];
        
        function initGridGraph() {
            const canvas = document.getElementById('gridGraph');
            const ctx = canvas.getContext('2d');
            
            // Draw grid
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 0.5;
            
            // Draw vertical grid lines
            const gridSize = 20;
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw darker lines every 5 grid cells
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += gridSize * 5) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSize * 5) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // Draw x and y axes
            ctx.beginPath();
            ctx.moveTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 40, canvas.height - 40); // x-axis
            ctx.moveTo(40, canvas.height - 40);
            ctx.lineTo(40, 40); // y-axis
            ctx.stroke();
            
            // Add arrows
            ctx.beginPath();
            ctx.moveTo(canvas.width - 40, canvas.height - 40);
            ctx.lineTo(canvas.width - 50, canvas.height - 45);
            ctx.lineTo(canvas.width - 50, canvas.height - 35);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(40, 40);
            ctx.lineTo(35, 50);
            ctx.lineTo(45, 50);
            ctx.fill();
            
            // Save initial state
            gridCanvasStates.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            function startDrawing(e) {
                isDrawing = true;
                [lastX, lastY] = getMousePos(canvas, e);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const [currentX, currentY] = getMousePos(canvas, e);
                
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                [lastX, lastY] = [currentX, currentY];
            }
            
            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    gridCanvasStates.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                }
            }
        }
        
        function clearGridCanvas() {
            const canvas = document.getElementById('gridGraph');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gridCanvasStates.length = 0;
            initGridGraph();
        }
        
        function undoGridStroke() {
            if (gridCanvasStates.length > 1) {
                gridCanvasStates.pop();
                const canvas = document.getElementById('gridGraph');
                const ctx = canvas.getContext('2d');
                ctx.putImageData(gridCanvasStates[gridCanvasStates.length - 1], 0, 0);
            }
        }
        
        // Initialize grid graph when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
            initGridGraph();
        });

        const forceDiagramStates = {
            forceT1: [],
            forceT2: []
        };
        
        function initForceDiagram(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            for (let x = 0; x <= canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();
            
            forceDiagramStates[canvasId] = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            
            let isDrawing = false;
            let startX = canvas.width/2;
            let startY = canvas.height/2;
            let currentArrow = null;
            
            function drawArrow(fromX, fromY, toX, toY) {
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const arrowLength = 15;
                
                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - arrowLength * Math.cos(angle - Math.PI/6),
                    toY - arrowLength * Math.sin(angle - Math.PI/6)
                );
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - arrowLength * Math.cos(angle + Math.PI/6),
                    toY - arrowLength * Math.sin(angle + Math.PI/6)
                );
                ctx.stroke();
            }
            
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const distFromCenter = Math.sqrt(
                    Math.pow(x - startX, 2) + 
                    Math.pow(y - startY, 2)
                );
                
                if (distFromCenter <= 15) {
                    isDrawing = true;
                    currentArrow = { fromX: startX, fromY: startY };
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                drawArrow(currentArrow.fromX, currentArrow.fromY, x, y);
            });
            
            canvas.addEventListener('mouseup', function(e) {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                drawArrow(currentArrow.fromX, currentArrow.fromY, x, y);
                forceDiagramStates[canvasId].push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                
                isDrawing = false;
                currentArrow = null;
            });
            
            canvas.addEventListener('mouseleave', function() {
                if (!isDrawing) return;
                
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
                isDrawing = false;
                currentArrow = null;
            });
        }
        
        function clearForceDiagram(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            forceDiagramStates[canvasId] = [];
            initForceDiagram(canvasId);
        }
        
        function undoForceStroke(canvasId) {
            if (forceDiagramStates[canvasId].length > 1) {
                forceDiagramStates[canvasId].pop();
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
            }
        }
        
        // Initialize force diagrams when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
            initGridGraph();
            initForceDiagram('forceT1');
            initForceDiagram('forceT2');
        });

        // Add submission handling
        const submissionModal = document.getElementById('submissionModal');
        const submitBtn = document.getElementById('submitBtn');
        const submitAnonymous = document.getElementById('submitAnonymous');
        const submitWithName = document.getElementById('submitWithName');
        const cancelSubmit = document.getElementById('cancelSubmit');
        const submitterName = document.getElementById('submitterName');

        submitBtn.addEventListener('click', () => {
            submissionModal.style.display = 'block';
        });

        cancelSubmit.addEventListener('click', () => {
            submissionModal.style.display = 'none';
        });

        // Function to collect all the answers from the document
        function collectAnswers() {
            const answers = {};
            
            // Get all answer spaces (textareas) throughout the test
            const answerSpaces = document.querySelectorAll('.answer-space');
            
            // First assign IDs to any answer spaces that don't have one
            answerSpaces.forEach((textarea, idx) => {
                if (!textarea.id) {
                    textarea.id = `answer_${idx + 1}`;
                }
            });
            
            // Now collect all answers, ensuring textareas with or without content are included
            answerSpaces.forEach(answerBox => {
                const id = answerBox.id;
                const questionNumber = id.replace('answer_', '');
                answers[id] = answerBox.value.trim() || "No answer provided";
            });
            
            // Collect canvas drawings and convert them to data URLs
            const canvasData = {};
            
            // Position graph
            const positionGraph = document.getElementById('positionGraph');
            if (positionGraph) {
                try {
                    // Always capture the canvas data URL regardless of content detection
                    canvasData.positionGraph = positionGraph.toDataURL('image/png');
                } catch (err) {
                    console.error("Error capturing position graph:", err);
                    canvasData.positionGraph = "Failed to capture drawing";
                }
            }
            
            // Velocity graph
            const velocityGraph = document.getElementById('velocityGraph');
            if (velocityGraph) {
                try {
                    canvasData.velocityGraph = velocityGraph.toDataURL('image/png');
                } catch (err) {
                    console.error("Error capturing velocity graph:", err);
                    canvasData.velocityGraph = "Failed to capture drawing";
                }
            }
            
            // Grid graph
            const gridGraph = document.getElementById('gridGraph');
            if (gridGraph) {
                try {
                    canvasData.gridGraph = gridGraph.toDataURL('image/png');
                } catch (err) {
                    console.error("Error capturing grid graph:", err);
                    canvasData.gridGraph = "Failed to capture drawing";
                }
            }
            
            // Force diagrams
            const forceT1 = document.getElementById('forceT1');
            if (forceT1) {
                try {
                    canvasData.forceT1 = forceT1.toDataURL('image/png');
                } catch (err) {
                    console.error("Error capturing force diagram T1:", err);
                    canvasData.forceT1 = "Failed to capture drawing";
                }
            }
            
            const forceT2 = document.getElementById('forceT2');
            if (forceT2) {
                try {
                    canvasData.forceT2 = forceT2.toDataURL('image/png');
                } catch (err) {
                    console.error("Error capturing force diagram T2:", err);
                    canvasData.forceT2 = "Failed to capture drawing";
                }
            }
            
            // Add canvas data to answers object
            answers.canvas_data = canvasData;
            
            return answers;
        }
        
        // Helper function to check if a canvas has been drawn on (legacy)
        function canvasHasContent(canvas) {
            // Always return true to ensure canvas data is included
            return true;
        }

        function countNonTransparentPixels(canvas) {
            const ctx = canvas.getContext('2d');
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            let count = 0;
            
            // Check alpha values (every 4th value in the array)
            for (let i = 3; i < imgData.length; i += 4) {
                if (imgData[i] > 0) {
                    count++;
                }
            }
            
            return count;
        }

        // Function to handle test submission
        async function submitTest(isAnonymous = false, providedName = null) {
            // Use the provided name if available, otherwise get it from the submitterName field
            let userName = isAnonymous ? "Anonymous Student" : (providedName || document.getElementById('submitterName').value.trim());
            
            if (!isAnonymous && (!userName || userName.length < 2)) {
                alert("Please enter your name or choose to submit anonymously.");
                return;
            }
            
            // Show loading state
            const submitButton = document.querySelector('#submitWithName');
            const anonymousButton = document.querySelector('#submitAnonymous');
            submitButton.disabled = true;
            anonymousButton.disabled = true;
            submitButton.textContent = 'Submitting...';
            
            try {
                // Collect all answers
                const answers = collectAnswers();
                
                // Create submission object
                const submission = {
                    name: userName,
                    testId: 'physics1frq',
                    testType: 'FRQ',
                    timestamp: new Date().toISOString(),
                    answers: answers
                };
                
                // Send to Discord webhook
                await sendAnswersAsMultipleMessages(userName, answers, DISCORD_WEBHOOK_URL);
                
                // Store submission in local storage for GitHub publishing
                storeSubmission(submission);
                
                // Hide the modal
                document.querySelector('.modal').style.display = 'none';
                
                // Show success message and offer to publish to GitHub
                if (confirm('Submission successfully sent to Discord! Would you like to publish it to GitHub as well?')) {
                    publishToGitHub(submission);
                } else {
                    alert('Your submission has been saved. You can publish it to GitHub later if you want.');
                }
            } catch (error) {
                console.error('Error submitting test:', error);
                alert(`Error submitting test: ${error.message}`);
            } finally {
                // Reset the buttons
                submitButton.disabled = false;
                anonymousButton.disabled = false;
                submitButton.textContent = 'Submit with Name';
            }
        }
        
        // Function to store a submission in local storage
        function storeSubmission(submission) {
            const submissions = JSON.parse(localStorage.getItem('testSubmissions') || '[]');
            submissions.push(submission);
            localStorage.setItem('testSubmissions', JSON.stringify(submissions));
        }

        // Function to send answers to Discord in multiple messages
        async function sendAnswersAsMultipleMessages(userName, answers, webhookURL) {
            // First send a header message with user details
            const headerPayload = {
                content: "",
                embeds: [{
                    title: `Complete FRQ Test Submission from ${userName}`,
                    description: "This submission includes text answers and canvas drawings.",
                    color: 3447003,
                    fields: [
                        {
                            name: "Student",
                            value: userName,
                            inline: true
                        },
                        {
                            name: "Test",
                            value: "AP Physics 1 FRQ",
                            inline: true
                        },
                        {
                            name: "Timestamp",
                            value: new Date().toISOString(),
                            inline: true
                        }
                    ]
                }]
            };
            
            // Send the header
            try {
                await fetch(webhookURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(headerPayload)
                });
                
                // Wait a bit before sending the rest to preserve message order
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                console.error("Error sending header message:", error);
                throw error;
            }
            
            // Get text answers only (exclude the canvas data)
            const textAnswers = Object.entries(answers)
                .filter(([key]) => key !== 'canvas_data')
                .sort((a, b) => {
                    // Extract numbers from keys to sort numerically
                    const numA = parseInt(a[0].replace('answer_', '')) || 0;
                    const numB = parseInt(b[0].replace('answer_', '')) || 0;
                    return numA - numB;
                });
            
            // Create a map to track which questions we've already sent
            const sentQuestions = new Set();
            
            // Split answers into chunks of 5 to avoid message limits
            for (let i = 0; i < textAnswers.length; i += 5) {
                const chunk = textAnswers.slice(i, i + 5);
                
                // Mark these questions as sent
                chunk.forEach(([key]) => sentQuestions.add(key));
                
                // Create a message payload for this chunk
                const chunkPayload = {
                    content: "",
                    embeds: [{
                        title: `Answers ${i + 1}-${Math.min(i + 5, textAnswers.length)}`,
                        color: 3447003,
                        fields: chunk.map(([key, value]) => ({
                            name: `Answer ${key.replace('answer_', '')}`,
                            value: value || 'No answer provided'
                        }))
                    }]
                };
                
                // Send this chunk of answers
                try {
                    await fetch(webhookURL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(chunkPayload)
                    });
                    
                    // Add a small delay between messages
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error("Error sending answer chunk:", error);
                    throw error;
                }
            }
            
            // Send canvas drawings if any exist
            if (answers.canvas_data && Object.keys(answers.canvas_data).length > 0) {
                const canvasDrawings = Object.entries(answers.canvas_data);
                
                // Send a header for the drawings
                const drawingsHeaderPayload = {
                    content: "**Canvas Drawings:**"
                };
                
                try {
                    await fetch(webhookURL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(drawingsHeaderPayload)
                    });
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                } catch (error) {
                    console.error("Error sending canvas header:", error);
                    throw error;
                }
                
                // Send each drawing as a separate message with image
                for (const [name, dataUrl] of canvasDrawings) {
                    let displayName = name;
                    switch(name) {
                        case 'positionGraph': displayName = 'Position vs. Time Graph'; break;
                        case 'velocityGraph': displayName = 'Velocity vs. Time Graph'; break;
                        case 'gridGraph': displayName = 'Data Grid'; break;
                        case 'forceT1': displayName = 'Force Diagram (t₁)'; break;
                        case 'forceT2': displayName = 'Force Diagram (t₂)'; break;
                        default: displayName = name.replace(/([A-Z])/g, ' $1').trim();
                    }
                    
                    // Handle both string messages and actual image data
                    if (typeof dataUrl === 'string' && dataUrl.startsWith('data:image/')) {
                        // It's an actual image
                        const drawingPayload = {
                            content: `**${displayName}:**`,
                            embeds: [{
                                title: displayName,
                                image: {
                                    url: dataUrl
                                },
                                color: 7506394
                            }]
                        };
                        
                        try {
                            const response = await fetch(webhookURL, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(drawingPayload)
                            });
                            
                            if (!response.ok) {
                                console.error(`Failed to send ${displayName} drawing: ${response.status}`);
                                // If image is too large, send a message about it
                                await fetch(webhookURL, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        content: `**${displayName}:** Too large to send via Discord. The image will be available on GitHub.`
                                    })
                                });
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (error) {
                            console.error(`Error sending canvas ${name}:`, error);
                            // If sending fails, try to send a message about it
                            try {
                                await fetch(webhookURL, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({
                                        content: `**${displayName}:** Failed to send. The image will be available on GitHub.`
                                    })
                                });
                            } catch (innerError) {
                                console.error(`Failed to send error message for ${name}:`, innerError);
                            }
                        }
                    } else {
                        // It's a message like "No drawing provided"
                        try {
                            await fetch(webhookURL, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    content: `**${displayName}:** ${dataUrl}`
                                })
                            });
                            await new Promise(resolve => setTimeout(resolve, 500));
                        } catch (error) {
                            console.error(`Error sending message for ${name}:`, error);
                        }
                    }
                }
            } else {
                // If no drawings exist, send a message about it
                try {
                    await fetch(webhookURL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            content: "**No drawings provided in this submission.**"
                        })
                    });
                } catch (error) {
                    console.error("Error sending no drawings message:", error);
                }
            }
            
            console.log("All messages sent successfully.");
            return true;
        }

        // Close modal if clicking outside
        window.addEventListener('click', (event) => {
            if (event.target === submissionModal) {
                submissionModal.style.display = 'none';
            }
        });

        // Test selection handling
        const testSelectionModal = document.getElementById('testSelectionModal');
        
        document.querySelectorAll('.test-item').forEach(item => {
            item.addEventListener('click', () => {
                const testId = item.dataset.test;
                window.location.href = `${testId}.html`;
            });
        });

        // Add redo states for each canvas
        const canvasRedoStates = {
            positionGraph: [],
            velocityGraph: [],
            gridGraph: [],
            forceT1: [],
            forceT2: []
        };

        // Add keyboard shortcut handling for the entire document
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey) {
                switch(event.key) {
                    case 'z':
                        event.preventDefault();
                        const activeCanvas = document.activeElement;
                        if (activeCanvas && activeCanvas.tagName === 'CANVAS') {
                            undoLastStroke(activeCanvas.id);
                        }
                        break;
                    case 'y':
                        event.preventDefault();
                        const activeCanvasForRedo = document.activeElement;
                        if (activeCanvasForRedo && activeCanvasForRedo.tagName === 'CANVAS') {
                            redoLastStroke(activeCanvasForRedo.id);
                        }
                        break;
                }
            }
        });

        function undoLastStroke(canvasId) {
            let states, redoStates;
            
            if (canvasId === 'gridGraph') {
                states = gridCanvasStates;
                redoStates = canvasRedoStates.gridGraph;
            } else if (canvasId === 'forceT1' || canvasId === 'forceT2') {
                states = forceDiagramStates[canvasId];
                redoStates = canvasRedoStates[canvasId];
            } else {
                states = canvasStates[canvasId];
                redoStates = canvasRedoStates[canvasId];
            }

            if (states && states.length > 1) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                redoStates.push(states.pop());
                ctx.putImageData(states[states.length - 1], 0, 0);
            }
        }

        function redoLastStroke(canvasId) {
            let states, redoStates;
            
            if (canvasId === 'gridGraph') {
                states = gridCanvasStates;
                redoStates = canvasRedoStates.gridGraph;
            } else if (canvasId === 'forceT1' || canvasId === 'forceT2') {
                states = forceDiagramStates[canvasId];
                redoStates = canvasRedoStates[canvasId];
            } else {
                states = canvasStates[canvasId];
                redoStates = canvasRedoStates[canvasId];
            }

            if (redoStates && redoStates.length > 0) {
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                const redoState = redoStates.pop();
                ctx.putImageData(redoState, 0, 0);
                states.push(redoState);
            }
        }

        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvasStates[canvasId] = [];
            canvasRedoStates[canvasId] = [];
            initCanvas(canvasId);
        }

        function clearGridCanvas() {
            const canvas = document.getElementById('gridGraph');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gridCanvasStates.length = 0;
            canvasRedoStates.gridGraph = [];
            initGridGraph();
        }

        function clearForceDiagram(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            forceDiagramStates[canvasId] = [];
            canvasRedoStates[canvasId] = [];
            initForceDiagram(canvasId);
        }

        function makeCanvasFocusable() {
            const canvases = document.querySelectorAll('canvas');
            canvases.forEach(canvas => {
                canvas.tabIndex = 0;
                canvas.addEventListener('mousedown', () => canvas.focus());
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
            initGridGraph();
            initForceDiagram('forceT1');
            initForceDiagram('forceT2');
            makeCanvasFocusable();
        });

        // Add this function to handle GitHub publishing
        function publishToGitHub(submission) {
            // Display a confirmation dialog
            const publishModal = document.createElement('div');
            publishModal.className = 'modal';
            publishModal.style.display = 'block';
            publishModal.style.position = 'fixed';
            publishModal.style.top = '0';
            publishModal.style.left = '0';
            publishModal.style.width = '100%';
            publishModal.style.height = '100%';
            publishModal.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            publishModal.style.zIndex = '1000';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.style.backgroundColor = 'rgba(0, 0, 32, 0.95)';
            modalContent.style.margin = '15% auto';
            modalContent.style.padding = '20px';
            modalContent.style.border = '1px solid #888';
            modalContent.style.width = '80%';
            modalContent.style.maxWidth = '500px';
            modalContent.style.borderRadius = '10px';
            modalContent.style.color = 'white';
            
            modalContent.innerHTML = `
                <h3>Publish to GitHub</h3>
                <p>This will publish your submission to the website for everyone to see.</p>
                <div class="form-group" style="margin: 15px 0;">
                    <label for="githubToken" style="display: block; margin-bottom: 5px;">GitHub Personal Access Token:</label>
                    <input type="password" id="githubToken" class="modal-input" placeholder="Enter your GitHub token" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ccc; border-radius: 5px; background-color: rgba(255, 255, 255, 0.1); color: white;">
                    <small style="display: block; color: #aaa; margin-top: 5px;">Required to publish to GitHub. 
                        <a href="https://github.com/settings/tokens" target="_blank" style="color: #88f;">Generate a token here</a> 
                        with 'repo' scope access.
                    </small>
                </div>
                <div class="form-group" style="margin: 15px 0;">
                    <p style="font-size: 14px; color: #ddd;">
                        Your submission will be published to:<br>
                        <span style="color: #fff; font-weight: bold;">Applethings/statswebsitewright</span>
                    </p>
                </div>
                <div class="modal-buttons" style="display: flex; justify-content: space-between; margin-top: 20px; gap: 10px;">
                    <button id="confirmPublish" class="modal-button" style="padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; background-color: #004d00; color: white;">Publish Submission</button>
                    <button id="cancelPublish" class="modal-button" style="padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; background-color: #660000; color: white;">Cancel</button>
                </div>
            `;
            
            publishModal.appendChild(modalContent);
            document.body.appendChild(publishModal);
            
            // Handle button clicks
            document.getElementById('confirmPublish').addEventListener('click', function() {
                const token = document.getElementById('githubToken').value.trim();
                
                if (!token) {
                    alert('GitHub token is required to publish submissions. Please generate one at https://github.com/settings/tokens with "repo" scope.');
                    return;
                }
                
                // Set repository details
                const owner = 'Applethings';
                const repo = 'statswebsitewright';
                
                // Show loading state
                document.getElementById('confirmPublish').textContent = 'Publishing...';
                document.getElementById('confirmPublish').disabled = true;
                
                // Add submission to local storage first (this makes it immediately accessible)
                const subject = "AP Physics 1"; // Determine based on test ID
                let allSubmissions = JSON.parse(localStorage.getItem('allTestSubmissions') || '{}');
                if (!allSubmissions[subject]) {
                    allSubmissions[subject] = [];
                }
                allSubmissions[subject].push(submission);
                localStorage.setItem('allTestSubmissions', JSON.stringify(allSubmissions));
                
                // Directly update the test-results.html file
                updateTestResultsHTML(owner, repo, token, submission)
                    .then(result => {
                        if (result.success) {
                            alert('Your submission has been published and can now be viewed on the Results page!');
                            document.body.removeChild(publishModal);
                            
                            // Optionally redirect to the test results page
                            if (confirm('Would you like to view your submission on the results page?')) {
                                window.location.href = 'test-results.html';
                            }
                        }
                    });
            });
            
            document.getElementById('cancelPublish').addEventListener('click', function() {
                document.body.removeChild(publishModal);
            });
            
            // Close modal if clicking outside
            publishModal.addEventListener('click', function(event) {
                if (event.target === publishModal) {
                    document.body.removeChild(publishModal);
                }
            });
        }

        // Function to directly update the test-results.html file with the submission
        async function updateTestResultsHTML(owner, repo, token, submission) {
            try {
                const filePath = 'test-results.html';
                
                // First, fetch the current content of the file
                const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!getResponse.ok) {
                    throw new Error(`Failed to fetch ${filePath}: ${getResponse.status}`);
                }
                
                const fileData = await getResponse.json();
                const content = atob(fileData.content);
                const sha = fileData.sha;
                
                // Determine the subject based on the testId
                let subject = "AP Physics 1";
                if (submission.testId.includes('physics1')) {
                    subject = "AP Physics 1";
                }
                // Add more subject mappings as needed for future tests
                
                // Determine if it's FRQ or MCQ
                const testType = submission.testType;
                
                // Add logging to debug canvas data
                console.log("Canvas data in submission:", 
                    submission.answers.canvas_data ? 
                    Object.keys(submission.answers.canvas_data).length : 
                    "No canvas data");
                
                if (submission.answers.canvas_data) {
                    // Log each canvas data URL (first 100 chars)
                    Object.entries(submission.answers.canvas_data).forEach(([key, value]) => {
                        console.log(`Canvas ${key} data type:`, typeof value);
                        if (typeof value === 'string') {
                            console.log(`Canvas ${key} is image:`, value.startsWith('data:image/'));
                            console.log(`Canvas ${key} starts with:`, value.substring(0, 100) + '...');
                        }
                    });
                }
                
                // Format the submission data for display
                const submissionHTML = formatSubmissionHTML(submission);
                console.log("Generated submission HTML length:", submissionHTML.length);
                
                // Update the JavaScript data structure
                let updatedContent = updateJavaScriptData(content, subject, submission);
                
                // Update the display containers
                const subjectDivId = subject.toLowerCase().replace(/\s+/g, '-');
                
                // Find or create the container for this subject
                if (!updatedContent.includes(`id="${subjectDivId}"`)) {
                    // Subject doesn't exist yet, add it to the test categories
                    updatedContent = addSubjectCategory(updatedContent, subject, subjectDivId);
                } else {
                    // Update the counter for the subject
                    updatedContent = updateSubjectCounter(updatedContent, subject, subjectDivId, testType);
                }
                
                // Add the submission to the appropriate container
                const containerId = `submissions-${testType.toLowerCase()}-${subjectDivId}`;
                if (!updatedContent.includes(`id="${containerId}"`)) {
                    // Container doesn't exist, create it
                    updatedContent = addSubmissionContainer(updatedContent, containerId, submissionHTML, subject, testType);
                } else {
                    // Container exists, add to it
                    updatedContent = addToSubmissionContainer(updatedContent, containerId, submissionHTML);
                }
                
                // Update the file on GitHub
                const updateResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Add ${testType} submission from ${submission.name} for ${subject}`,
                        content: utf8ToBase64(updatedContent),
                        sha: sha,
                        branch: 'main'
                    })
                });
                
                // Function to convert UTF-8 string to base64
                function utf8ToBase64(str) {
                    try {
                        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {
                            return String.fromCharCode('0x' + p1);
                        }));
                    } catch (e) {
                        console.error("Encoding error:", e);
                        // Fallback method if the above fails
                        return btoa(unescape(encodeURIComponent(str)));
                    }
                }
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json();
                    throw new Error(`Failed to update ${filePath}: ${errorData.message}`);
                }
                
                console.log(`Successfully updated test-results.html with ${testType} submission for ${subject}`);
                return { success: true };
            } catch (error) {
                console.error('Error updating test-results.html:', error);
                alert(`Error publishing to GitHub: ${error.message}`);
                return { success: false, error: error.message };
            }
        }

        // Function to handle zooming in on images when clicked
        function zoomImage(img) {
            // Create a modal for the zoomed image
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.8)';
            modal.style.zIndex = '1000';
            modal.style.display = 'flex';
            modal.style.justifyContent = 'center';
            modal.style.alignItems = 'center';
            modal.style.cursor = 'pointer';
            
            // Create the zoomed image
            const zoomedImg = document.createElement('img');
            zoomedImg.src = img.src;
            zoomedImg.style.maxWidth = '90%';
            zoomedImg.style.maxHeight = '90%';
            zoomedImg.style.objectFit = 'contain';
            zoomedImg.style.border = '2px solid white';
            
            // Add click event to close the modal
            modal.onclick = function() {
                document.body.removeChild(modal);
            };
            
            // Add the image to the modal and the modal to the body
            modal.appendChild(zoomedImg);
            document.body.appendChild(modal);
        }
        
        // Add the zoomImage function to the window object for access from the HTML
        window.zoomImage = zoomImage;

        // Helper function to update the JavaScript data in the HTML
        function updateJavaScriptData(content, subject, submission) {
            // Create a copy of the submission that we can safely serialize
            const serializableSubmission = JSON.parse(JSON.stringify(submission));
            
            // This just adds it to localStorage on load
            // Add this after the displayTestCategories() call
            const script = `
                // Add newest submission to localStorage
                (function() {
                    let allSubmissions = JSON.parse(localStorage.getItem('allTestSubmissions') || '{}');
                    if (!allSubmissions['${subject}']) {
                        allSubmissions['${subject}'] = [];
                    }
                    // Check if submission already exists
                    const exists = allSubmissions['${subject}'].some(s => 
                        s.name === '${submission.name}' && 
                        s.timestamp === '${submission.timestamp}' &&
                        s.testType === '${submission.testType}'
                    );
                    if (!exists) {
                        allSubmissions['${subject}'].push(${JSON.stringify(serializableSubmission)});
                        localStorage.setItem('allTestSubmissions', JSON.stringify(allSubmissions));
                    }
                })();
            `;
            
            return content.replace('displayTestCategories();', `displayTestCategories();\n        ${script}`);
        }
    </script>
</body>
</html> 