<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AP Physics 1 2023 FRQ</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            min-height: 100vh;
            background: url('images/bgg.gif') no-repeat center center fixed;
            background-size: cover;
            font-family: Arial, sans-serif;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .content {
            background-color: rgba(0, 0, 0, 0.6);
            padding: 40px;
            margin: 40px;
            border-radius: 10px;
            max-width: 800px;
            width: 90%;
        }
        .page {
            display: none;
        }
        .page.active {
            display: block;
        }
        .navigation {
            position: fixed;
            bottom: 20px;
            display: flex;
            gap: 20px;
            background-color: rgba(0, 0, 32, 0.4);
            padding: 10px 20px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        .nav-button {
            background-color: rgba(0, 0, 128, 0.3);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        .nav-button:hover {
            background-color: rgba(0, 0, 128, 0.5);
        }
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 128, 0.6);
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            text-decoration: none;
            transition: background-color 0.3s ease;
        }
        .back-button:hover {
            background-color: rgba(0, 0, 128, 0.8);
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .page-number {
            color: white;
            margin: 0 20px;
        }
        .question-image {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #000;
            border-radius: 5px;
        }
        .question-text {
            margin-bottom: 20px;
        }
        .sub-question {
            margin-top: 15px;
            margin-bottom: 15px;
        }
        .math {
            font-style: italic;
        }
        .data-table {
            margin: 20px 0;
            overflow-x: auto;
        }
        .data-table table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .data-table th, .data-table td {
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px;
            text-align: center;
        }
        .data-table th {
            background-color: rgba(0, 0, 128, 0.3);
        }
        .data-table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .answer-space {
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            min-height: 120px;
            margin: 15px 0;
            padding: 10px;
            width: 100%;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
        }
        .answer-space:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            background-color: rgba(255, 255, 255, 0.15);
        }
        .short-answer-space {
            min-height: 80px;
        }
        .long-answer-space {
            min-height: 150px;
        }
        .graph-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 20px 0;
        }
        .graph-box {
            flex: 1;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 5px;
            padding: 10px;
        }
        .graph-title {
            text-align: center;
            color: black;
            margin-bottom: 10px;
        }
        canvas {
            background-color: white;
            border: 1px solid #ccc;
            cursor: crosshair;
        }
        .graph-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        .graph-button {
            background-color: #333;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .graph-button:hover {
            background-color: #444;
        }
        .grid-graph-container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .grid-canvas {
            background-color: white;
            border: 1px solid #000;
        }
        .force-diagram-container {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }
        .force-diagram {
            background-color: white;
            border: 1px solid #000;
        }
        .diagram-label {
            text-align: center;
            color: black;
            margin-top: 5px;
            font-size: 14px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }
        .modal-content {
            background-color: rgba(0, 0, 32, 0.95);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 10px;
            color: white;
        }
        .modal-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
            gap: 10px;
        }
        .modal-button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: rgba(0, 0, 128, 0.5);
            color: white;
            transition: background-color 0.3s;
        }
        .modal-button:hover {
            background-color: rgba(0, 0, 128, 0.8);
        }
        #submitAnonymous {
            background-color: #666;
        }
        #submitWithName {
            background-color: #004d00;
        }
        #cancelSubmit {
            background-color: #660000;
        }
        .test-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .test-item {
            background-color: rgba(0, 0, 128, 0.3);
            margin: 10px 0;
            padding: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .test-item:hover {
            background-color: rgba(0, 0, 128, 0.5);
        }
        .test-item h4 {
            margin: 0 0 10px 0;
        }
        .test-item p {
            margin: 0;
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <a href="physics1.html" class="back-button">Back</a>
    
    <div class="content">
        <div class="page active" id="page1">
            <h1>AP Physics 1 2023 Free-Response Questions</h1>
            <h2>Section II</h2>
            <h3>Time—1 hour and 30 minutes</h3>
            <h3>5 Questions</h3>
            <br>
            <h3>Directions:</h3>
            <p>Questions 1, 4, and 5 are short free-response questions that require about 13 minutes each to answer and are worth 7 points each. Questions 2 and 3 are long free-response questions that require about 25 minutes each to answer and are worth 12 points each. Show your work for each part in the space provided after that part.</p>
        </div>
        
        <div class="page" id="page2">
            <h2>Question 1 (7 points)</h2>
            <div class="question-text">
                <p>A cart on a horizontal surface is attached to a spring. The other end of the spring is attached to a wall. The cart is initially held at rest, as shown in Figure 1. When the cart is released, the system consisting of the cart and spring oscillates between the positions <span class="math">x = +L</span> and <span class="math">x = -L</span>. Figure 2 shows the kinetic energy of the cart-spring system as a function of the system's potential energy. Frictional forces are negligible.</p>
            </div>
            <img src="images/image1.png" alt="Physics problem diagram" class="question-image">
            <div class="sub-question">
                <p>(a) On the graph of kinetic energy <span class="math">K</span> versus potential energy <span class="math">U</span> shown in Figure 2, the values for the <span class="math">x</span>-intercept and <span class="math">y</span>-intercept are the same. Briefly explain why this is true, using physics principles.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) When the cart is at <span class="math">+L</span> and momentarily at rest, a block is dropped onto the cart, as shown in Figure 3. The block sticks to the cart, and the block-cart-spring system continues to oscillate between <span class="math">-L</span> and <span class="math">+L</span>. The masses of the cart and the block are <span class="math">m₀</span> and <span class="math">3m₀</span>, respectively. The frequency of oscillation before the block is dropped onto the cart is <span class="math">f₁</span>. The frequency of oscillation after the block is dropped onto the cart is <span class="math">f₂</span>. Calculate the numerical value of the ratio <span class="math">f₂/f₁</span>.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) The dashed line in Figure 4 shows the kinetic energy <span class="math">K</span> versus potential energy <span class="math">U</span> of the block-cart-spring system after the block is dropped onto the cart. This graph is identical to the graph shown in Figure 2 for the cart-spring system before the block is dropped onto the cart.</p>
                <p>i. Briefly explain why the two graphs must be the same, using physics principles.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. After the block is dropped onto the cart, consider a system that consists only of the cart and the spring. On Figure 4, sketch a solid line that shows the kinetic energy of the system that consists of the cart and the spring but not the block after the block is dropped onto the cart.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page3">
            <h2>Question 2 (12 points)</h2>
            <div class="question-text">
                <p>Students conduct an experiment to determine the acceleration <span class="math">a</span> of a cart. The cart is released from rest at the top of the ramp at time <span class="math">t = 0</span> and moves down the ramp. The <span class="math">x</span>-axis is defined to be parallel to the ramp with its origin at the top, as shown in the figure. The students collect the data shown in the following table.</p>
            </div>
            <img src="images/image2.png" alt="Physics problem diagram" class="question-image">
            <div class="data-table">
                <table>
                    <tr>
                        <th>Position <span class="math">x</span> (m)</th>
                        <th>Time <span class="math">t</span> (s)</th>
                    </tr>
                    <tr><td>0.06</td><td>0.39</td></tr>
                    <tr><td>0.14</td><td>0.59</td></tr>
                    <tr><td>0.24</td><td>0.77</td></tr>
                    <tr><td>0.37</td><td>0.96</td></tr>
                    <tr><td>0.55</td><td>1.20</td></tr>
                </table>
            </div>
            <div class="sub-question">
                <p>(a)</p>
                <p>i. Indicate which quantities could be graphed to yield a straight line whose slope could be used to determine the acceleration <span class="math">a</span> of the cart. You may use the remaining columns in the table, as needed, to record any quantities (including units) that are not already in the table.</p>
                <p>Vertical axis: Horizontal axis: </p>
                <textarea class="answer-space short-answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. On the following grid, plot the appropriate quantities to create a graph that can be used to determine the acceleration <span class="math">a</span> of the cart as it rolls down the ramp. Clearly scale and label all axes (including units), as appropriate. Draw a straight line that best represents the data.</p>
                <div class="grid-graph-container">
                    <canvas id="gridGraph" width="500" height="400" class="grid-canvas"></canvas>
                    <div class="graph-controls">
                        <button class="graph-button" onclick="clearGridCanvas()">Clear</button>
                        <button class="graph-button" onclick="undoGridStroke()">Undo</button>
                    </div>
                </div>
                <p>iii. Using the line you drew in part (a)(ii), calculate an experimental value for the acceleration <span class="math">a</span> of the cart as it rolls down the ramp.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) The students are asked to determine an experimental value for the acceleration due to gravity <span class="math">g<sub>exp</sub></span> using their data.</p>
                <p>i. What additional quantities do the students need to measure in order to calculate <span class="math">g<sub>exp</sub></span> from <span class="math">a</span>?</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Write an expression for the value of <span class="math">g<sub>exp</sub></span> in terms of <span class="math">a</span>.</p>
                <textarea class="answer-space short-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) The students calculate the value of <span class="math">g<sub>exp</sub></span> to be significantly lower than the accepted value of 9.8 m/s².</p>
                <p>i. What is a physical reason, other than friction or air resistance, that could lead to a significant difference in the experimentally determined value of <span class="math">g<sub>exp</sub></span>?</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Briefly explain how the physical reason you identified in part (c)(i) would lead to the decrease in the experimentally determined value of <span class="math">g<sub>exp</sub></span>.</p>
                <img src="images/image3.png" alt="Physics problem diagram" class="question-image">
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(d) The students want to confirm that the acceleration is the same whether the cart rolls up or down the ramp. The students start the cart at the bottom and give the cart a quick push so that it rolls up the ramp and momentarily comes to rest. The <span class="math">x</span>-axis is still defined to be parallel to the ramp with the origin at the top.</p>
                <p>On the following graphs, sketch the position <span class="math">x</span> and velocity <span class="math">v</span> as functions of time <span class="math">t</span> that correspond to the scenario shown while the cart moves up the ramp.</p>
                <div class="graph-container">
                    <div class="graph-box">
                        <div class="graph-title">Position vs. Time</div>
                        <canvas id="positionGraph" width="350" height="350"></canvas>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearCanvas('positionGraph')">Clear</button>
                            <button class="graph-button" onclick="undoLastStroke('positionGraph')">Undo</button>
                        </div>
                    </div>
                    <div class="graph-box">
                        <div class="graph-title">Velocity vs. Time</div>
                        <canvas id="velocityGraph" width="350" height="350"></canvas>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearCanvas('velocityGraph')">Clear</button>
                            <button class="graph-button" onclick="undoLastStroke('velocityGraph')">Undo</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="page" id="page4">
            <h2>Question 3 (12 points)</h2>
            <img src="images/image6.png" alt="Physics problem diagram" class="question-image">
            <div class="question-text">
                <p>A small block of mass <span class="math">m₀</span> is attached to the end of a spring of spring constant <span class="math">k₀</span> that is attached to a rod on a horizontal table. The rod is attached to a motor so that the rod can rotate at various speeds about its axis. When the rod is not rotating, the block is at rest and the spring is at its unstretched length <span class="math">L</span>, as shown. All frictional forces are negligible.</p>
            </div>
            <img src="images/image7.png" alt="Physics problem diagram showing Figure 1 and Figure 2" class="question-image">
            <div class="sub-question">
                <p>(a) At time <span class="math">t = t₁</span>, the rod is spinning such that the block moves in a circular path with a constant tangential speed <span class="math">v₁</span> and the spring is stretched a distance <span class="math">d₁</span> from the spring's unstretched length, as shown in Figure 1. At time <span class="math">t = t₂</span>, the rod is spinning such that the block moves in a circular path with a constant tangential speed <span class="math">v₂</span> and the spring is stretched a distance <span class="math">d₂</span> from the spring's unstretched length, where <span class="math">d₂ > d₁</span>, as shown in Figure 2.</p>
                <p>i. On the following dots, which represent the block at the locations shown in Figure 1 and Figure 2, draw the force that is exerted on the block by the spring at times <span class="math">t = t₁</span> and <span class="math">t = t₂</span>. The spring force must be represented by a distinct arrow starting on, and pointing away from, the dot.</p>
                <p><em>Note: Draw the relative lengths of the vectors to reflect the relative magnitudes of the forces exerted by the spring at both times.</em></p>
                <div class="force-diagram-container">
                    <div>
                        <canvas id="forceT1" width="200" height="200" class="force-diagram"></canvas>
                        <div class="diagram-label">t = t₁</div>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearForceDiagram('forceT1')">Clear</button>
                            <button class="graph-button" onclick="undoForceStroke('forceT1')">Undo</button>
                        </div>
                    </div>
                    <div>
                        <canvas id="forceT2" width="200" height="200" class="force-diagram"></canvas>
                        <div class="diagram-label">t = t₂</div>
                        <div class="graph-controls">
                            <button class="graph-button" onclick="clearForceDiagram('forceT2')">Clear</button>
                            <button class="graph-button" onclick="undoForceStroke('forceT2')">Undo</button>
                        </div>
                    </div>
                </div>
                <p>ii. Referencing <span class="math">d₁</span> and <span class="math">d₂</span>, describe your reasoning for drawing the arrows the length that you did in part (a)(i).</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <img src="images/image10.png" alt="Physics problem diagram showing Figure 3" class="question-image">
                <p>iii. Is the tangential speed <span class="math">v₁</span> of the block at time <span class="math">t = t₁</span> greater than, less than, or equal to the tangential speed <span class="math">v₂</span> of the block at time <span class="math">t = t₂</span>?</p>
                <p>Justify your answer without using equations.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(b) Consider a scenario where the block travels in a circular path where the spring is stretched a distance <span class="math">d</span> from its unstretched length <span class="math">L</span>.</p>
                <p>i. Determine an expression for the magnitude of the net force <span class="math">F<sub>net</sub></span> exerted on the block. Express your answer in terms of <span class="math">m₀</span>, <span class="math">k₀</span>, <span class="math">L</span>, <span class="math">d</span>, and fundamental constants, as appropriate.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Derive an equation for the tangential speed <span class="math">v</span> of the block. Express your answer in terms of <span class="math">m₀</span>, <span class="math">k₀</span>, <span class="math">L</span>, <span class="math">d</span>, and fundamental constants, as appropriate.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <div class="sub-question">
                <p>(c) Does your equation for the tangential speed <span class="math">v</span> of the block from part (b)(ii) agree with your reasoning from part (a)?</p>
                <p>Explain your reasoning.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page5">
            <h2>Question 4 (7 points)</h2>
            <div class="question-text">
                <img src="images/image4.png" alt="Physics problem diagram" class="question-image">
                <p>A block of unknown mass is attached to a long, lightweight string that is wrapped several turns around a pulley mounted on a horizontal axis through its center, as shown. The pulley is a uniform solid disk of mass \(M\) and radius \(R\). The rotational inertia of the pulley is described by the equation \(I = \frac{1}{2}MR^2\). The pulley can rotate about its center with negligible friction. The string does not slip on the pulley as the block falls.</p>
                <p>When the block is released from rest and as the block travels toward the ground, the magnitude of the tension exerted on the block by the string is \(F_T\).</p>
            </div>
            <div class="sub-question">
                <p>(a) Determine an expression for the magnitude of the angular acceleration \(\alpha_D\) of the disk as the block travels downward. Express your answer in terms of \(M\), \(R\), \(F_T\), and physical constants as appropriate.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <img src="images/image5.png" alt="Physics problem diagram" class="question-image">
            </div>
            <div class="sub-question">
                <p>(b) Scenarios 1 and 2 show two different pulleys. In Scenario 1, the pulley is the same solid disk referenced in part (a). In Scenario 2, the pulley is a hoop that has the same mass \(M\) and radius \(R\) as the disk. Each pulley has a lightweight string wrapped around it several turns and is mounted on a horizontal axle, as shown. Each pulley is free to rotate about its center with negligible friction.</p>
                <p>In both scenarios, the pulleys begin at rest. Then both strings are pulled with the same constant force \(F_A\) for the same time interval \(\Delta t\), causing the pulleys to rotate without the string slipping. After time interval \(\Delta t\), the change in angular momentum of the disk is equal to the change in angular momentum of the hoop, but the change in rotational kinetic energy for the disk is greater than that of the hoop.</p>
                <p>In a clear, coherent paragraph-length response that may also contain equations and drawings, explain why the change in angular momentum of both pulleys is the same but the change in rotational kinetic energy is greater for the disk.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>

        <div class="page" id="page6">
            <h2>Question 5 (7 points)</h2>
            <img src="images/image8.png" alt="Physics problem diagram showing rod-sphere system" class="question-image">
            <div class="question-text">
                <p>A rod with a sphere attached to the end is connected to a horizontal mounted axle and carefully balanced so that it rests in a position vertically upward from the axle. The center of mass of the rod-sphere system is indicated with a \(\otimes\), as shown in Figure 1. The sphere is lightly tapped, and the rod-sphere system rotates clockwise with negligible friction about the axle due to the gravitational force.</p>
                <p>A student takes a video of the rod rotating from the vertically upward position to the vertically downward position. Figure 2 shows five frames (still shots) that the student selected from the video. <em>Note: these frames are not equally spaced apart in time.</em></p>
            </div>
            <img src="images/image9.png" alt="Physics problem diagram showing video frames" class="question-image">
            <div class="sub-question">
                <p>(a) Use the frames of the video shown in Figure 2 to answer the following questions.</p>
                <p>i. In which frame is the angular acceleration of the rod-sphere system the greatest? Justify your answer.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. In which frame is the rotational kinetic energy of the rod-sphere system the greatest? Briefly justify your answer.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
            <img src="images/image10.png" alt="Physics problem diagram showing Figure 3" class="question-image">
            <div class="sub-question">
                <p>(b) The rod-sphere system has mass \(M\) and length \(L\), and the center of mass is located a distance \(\frac{3}{4}L\) from the axle, shown in Figure 3.</p>
                <p>i. Derive an expression for the change in kinetic energy of the rod-sphere-Earth system from the moment shown in Frame A to the moment shown in Frame E. Express your answer in terms of \(M\), \(L\), and fundamental constants, as appropriate.</p>
                <textarea class="answer-space long-answer-space" placeholder="Enter your answer here..."></textarea>
                <p>ii. Briefly explain why the rod and sphere gain kinetic energy, even if Earth is not included in the system.</p>
                <textarea class="answer-space" placeholder="Enter your answer here..."></textarea>
            </div>
        </div>
    </div>

    <div class="navigation">
        <button class="nav-button" id="prevBtn">←</button>
        <span class="page-number">Page <span id="currentPage">1</span></span>
        <button class="nav-button" id="nextBtn">→</button>
        <button class="nav-button" id="submitBtn" style="background-color: #004d00;">Submit Test</button>
    </div>

    <!-- Submission Modal -->
    <div id="submissionModal" class="modal">
        <div class="modal-content">
            <h3>Submit Your Test</h3>
            <p>Please enter your name or choose to submit anonymously:</p>
            <input type="text" id="submitterName" placeholder="Your Name" class="modal-input">
            <div class="modal-buttons">
                <button id="submitAnonymous" class="modal-button">Submit Anonymously</button>
                <button id="submitWithName" class="modal-button">Submit with Name</button>
                <button id="cancelSubmit" class="modal-button">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Test Selection Modal -->
    <div id="testSelectionModal" class="modal">
        <div class="modal-content">
            <h3>Select a Test</h3>
            <div class="test-list">
                <div class="test-item" data-test="physics1test">
                    <h4>AP Physics 1 - 2023 FRQ</h4>
                    <p>Free Response Questions from the 2023 AP Physics 1 exam</p>
                </div>
                <!-- More tests can be added here -->
            </div>
        </div>
    </div>

    <script>
        let currentPageIndex = 1;
        const totalPages = 6;

        function updatePage() {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            
            document.getElementById(`page${currentPageIndex}`).classList.add('active');
            
            document.getElementById('currentPage').textContent = currentPageIndex;
            
            document.getElementById('prevBtn').disabled = currentPageIndex === 1;
            document.getElementById('nextBtn').disabled = currentPageIndex === totalPages;
        }

        document.getElementById('prevBtn').addEventListener('click', () => {
            if (currentPageIndex > 1) {
                currentPageIndex--;
                updatePage();
            }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (currentPageIndex < totalPages) {
                currentPageIndex++;
                updatePage();
            }
        });

        updatePage();

        const canvasStates = {
            positionGraph: [],
            velocityGraph: []
        };
        
        function initCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // Draw x-axis
            ctx.beginPath();
            ctx.moveTo(50, canvas.height/2);
            ctx.lineTo(canvas.width - 20, canvas.height/2);
            ctx.stroke();
            
            // Draw y-axis
            ctx.beginPath();
            ctx.moveTo(50, canvas.height - 20);
            ctx.lineTo(50, 20);
            ctx.stroke();
            
            // Add arrows
            ctx.beginPath();
            ctx.moveTo(canvas.width - 20, canvas.height/2);
            ctx.lineTo(canvas.width - 30, canvas.height/2 - 10);
            ctx.lineTo(canvas.width - 30, canvas.height/2 + 10);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(50, 20);
            ctx.lineTo(40, 30);
            ctx.lineTo(60, 30);
            ctx.fill();
            
            // Add labels
            ctx.font = '14px Arial';
            ctx.fillStyle = '#000';
            ctx.fillText('t', canvas.width - 20, canvas.height/2 + 20);
            ctx.fillText(canvasId === 'positionGraph' ? 'x' : 'v', 30, 30);
            ctx.fillText('O', 35, canvas.height/2 + 15);
            
            // Save initial state
            canvasStates[canvasId] = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            function startDrawing(e) {
                isDrawing = true;
                [lastX, lastY] = getMousePos(canvas, e);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const [currentX, currentY] = getMousePos(canvas, e);
                
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                [lastX, lastY] = [currentX, currentY];
            }
            
            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    canvasStates[canvasId].push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                }
            }
        }
        
        function getMousePos(canvas, e) {
            const rect = canvas.getBoundingClientRect();
            return [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
        }
        
        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvasStates[canvasId] = [];
            initCanvas(canvasId);
        }
        
        function undoLastStroke(canvasId) {
            if (canvasStates[canvasId].length > 1) {
                canvasStates[canvasId].pop();
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                ctx.putImageData(canvasStates[canvasId][canvasStates[canvasId].length - 1], 0, 0);
            }
        }
        
        // Initialize both canvases when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
        });

        const gridCanvasStates = [];
        
        function initGridGraph() {
            const canvas = document.getElementById('gridGraph');
            const ctx = canvas.getContext('2d');
            
            // Draw grid
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 0.5;
            
            // Draw vertical grid lines
            const gridSize = 20;
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw horizontal grid lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw darker lines every 5 grid cells
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += gridSize * 5) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += gridSize * 5) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            
            // Draw x and y axes
            ctx.beginPath();
            ctx.moveTo(40, canvas.height - 40);
            ctx.lineTo(canvas.width - 40, canvas.height - 40); // x-axis
            ctx.moveTo(40, canvas.height - 40);
            ctx.lineTo(40, 40); // y-axis
            ctx.stroke();
            
            // Add arrows
            ctx.beginPath();
            ctx.moveTo(canvas.width - 40, canvas.height - 40);
            ctx.lineTo(canvas.width - 50, canvas.height - 45);
            ctx.lineTo(canvas.width - 50, canvas.height - 35);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            ctx.beginPath();
            ctx.moveTo(40, 40);
            ctx.lineTo(35, 50);
            ctx.lineTo(45, 50);
            ctx.fill();
            
            // Save initial state
            gridCanvasStates.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            function startDrawing(e) {
                isDrawing = true;
                [lastX, lastY] = getMousePos(canvas, e);
            }
            
            function draw(e) {
                if (!isDrawing) return;
                
                const [currentX, currentY] = getMousePos(canvas, e);
                
                ctx.beginPath();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(currentX, currentY);
                ctx.stroke();
                
                [lastX, lastY] = [currentX, currentY];
            }
            
            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    gridCanvasStates.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                }
            }
        }
        
        function clearGridCanvas() {
            const canvas = document.getElementById('gridGraph');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            gridCanvasStates.length = 0;
            initGridGraph();
        }
        
        function undoGridStroke() {
            if (gridCanvasStates.length > 1) {
                gridCanvasStates.pop();
                const canvas = document.getElementById('gridGraph');
                const ctx = canvas.getContext('2d');
                ctx.putImageData(gridCanvasStates[gridCanvasStates.length - 1], 0, 0);
            }
        }
        
        // Initialize grid graph when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
            initGridGraph();
        });

        const forceDiagramStates = {
            forceT1: [],
            forceT2: []
        };
        
        function initForceDiagram(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            
            for (let x = 0; x <= canvas.width; x += 20) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y <= canvas.height; y += 20) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 5, 0, 2 * Math.PI);
            ctx.fillStyle = 'black';
            ctx.fill();
            
            forceDiagramStates[canvasId] = [ctx.getImageData(0, 0, canvas.width, canvas.height)];
            
            let isDrawing = false;
            let startX = canvas.width/2;
            let startY = canvas.height/2;
            let currentArrow = null;
            
            function drawArrow(fromX, fromY, toX, toY) {
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
                
                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const arrowLength = 15;
                
                ctx.beginPath();
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - arrowLength * Math.cos(angle - Math.PI/6),
                    toY - arrowLength * Math.sin(angle - Math.PI/6)
                );
                ctx.moveTo(toX, toY);
                ctx.lineTo(
                    toX - arrowLength * Math.cos(angle + Math.PI/6),
                    toY - arrowLength * Math.sin(angle + Math.PI/6)
                );
                ctx.stroke();
            }
            
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                const distFromCenter = Math.sqrt(
                    Math.pow(x - startX, 2) + 
                    Math.pow(y - startY, 2)
                );
                
                if (distFromCenter <= 15) {
                    isDrawing = true;
                    currentArrow = { fromX: startX, fromY: startY };
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                drawArrow(currentArrow.fromX, currentArrow.fromY, x, y);
            });
            
            canvas.addEventListener('mouseup', function(e) {
                if (!isDrawing) return;
                
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                drawArrow(currentArrow.fromX, currentArrow.fromY, x, y);
                forceDiagramStates[canvasId].push(ctx.getImageData(0, 0, canvas.width, canvas.height));
                
                isDrawing = false;
                currentArrow = null;
            });
            
            canvas.addEventListener('mouseleave', function() {
                if (!isDrawing) return;
                
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
                isDrawing = false;
                currentArrow = null;
            });
        }
        
        function clearForceDiagram(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            forceDiagramStates[canvasId] = [];
            initForceDiagram(canvasId);
        }
        
        function undoForceStroke(canvasId) {
            if (forceDiagramStates[canvasId].length > 1) {
                forceDiagramStates[canvasId].pop();
                const canvas = document.getElementById(canvasId);
                const ctx = canvas.getContext('2d');
                ctx.putImageData(forceDiagramStates[canvasId][forceDiagramStates[canvasId].length - 1], 0, 0);
            }
        }
        
        // Initialize force diagrams when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initCanvas('positionGraph');
            initCanvas('velocityGraph');
            initGridGraph();
            initForceDiagram('forceT1');
            initForceDiagram('forceT2');
        });

        // Add submission handling
        const submissionModal = document.getElementById('submissionModal');
        const submitBtn = document.getElementById('submitBtn');
        const submitAnonymous = document.getElementById('submitAnonymous');
        const submitWithName = document.getElementById('submitWithName');
        const cancelSubmit = document.getElementById('cancelSubmit');
        const submitterName = document.getElementById('submitterName');

        submitBtn.addEventListener('click', () => {
            submissionModal.style.display = 'block';
        });

        cancelSubmit.addEventListener('click', () => {
            submissionModal.style.display = 'none';
        });

        function collectAnswers() {
            const answers = {};
            
            // Collect text answers
            document.querySelectorAll('.answer-space').forEach((textarea, index) => {
                answers[`answer_${index + 1}`] = textarea.value;
            });

            // Collect canvas drawings
            const canvasData = {};
            
            // Helper function to properly get canvas image
            const getCanvasImage = (canvasId) => {
                try {
                    const canvas = document.getElementById(canvasId);
                    if (!canvas) {
                        console.error(`Canvas element not found: ${canvasId}`);
                        return null;
                    }
                    
                    console.log(`Getting data URL for ${canvasId}`);
                    
                    // Save canvas state before adding background
                    const ctx = canvas.getContext('2d');
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    // Add white background to ensure the drawing is visible
                    ctx.globalCompositeOperation = 'destination-over';
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Get the data URL with white background
                    const dataUrl = canvas.toDataURL('image/png', 1.0);
                    console.log(`${canvasId} data URL length: ${dataUrl.length}`);
                    
                    // Restore original canvas state
                    ctx.putImageData(imageData, 0, 0);
                    
                    return dataUrl;
                } catch (error) {
                    console.error(`Error capturing canvas ${canvasId}:`, error);
                    return null;
                }
            };
            
            // Get each canvas image
            const canvasList = ['positionGraph', 'velocityGraph', 'gridGraph', 'forceT1', 'forceT2'];
            canvasList.forEach(canvasId => {
                const imageUrl = getCanvasImage(canvasId);
                if (imageUrl) {
                    canvasData[canvasId] = imageUrl;
                }
            });

            // Add canvas data to answers
            answers['canvas_data'] = canvasData;
            
            console.log(`Collected answers with ${Object.keys(canvasData).length} canvas drawings`);
            
            return answers;
        }

        async function submitTest() {
            try {
                const name = document.getElementById('name').value.trim();
                if (!name) {
                    alert('Please enter your name before submitting.');
                    return;
                }

                // Get answers and canvas drawings
                const answers = collectAnswers();
                console.log("Collected answers:", answers);
                console.log("Canvas data count:", answers.canvas_data ? Object.keys(answers.canvas_data).length : 0);
                
                // For debugging, show canvas images in console
                if (answers.canvas_data) {
                    Object.entries(answers.canvas_data).forEach(([key, value]) => {
                        console.log(`Canvas ${key} data length: ${value ? value.length : 0}`);
                    });
                }

                // Create submission object
                const submission = {
                    testType: 'AP Physics 1',
                    testId: 'physics1',
                    timestamp: new Date().toISOString(),
                    name: name,
                    answers: answers
                };

                // Save to session storage for GitHub publishing
                const publishKey = `publish_${Date.now()}`;
                sessionStorage.setItem(publishKey, JSON.stringify(submission));
                console.log("Saved submission to session storage with key:", publishKey);

                // Show GitHub publishing UI
                const publishContainer = document.createElement('div');
                publishContainer.className = 'publish-container';
                publishContainer.style.cssText = 'margin-top: 20px; padding: 15px; border: 2px solid #4CAF50; border-radius: 5px; background-color: #f8f8f8;';
                
                publishContainer.innerHTML = `
                    <h3 style="color: #2E7D32; margin-top: 0;">📝 Submission Complete!</h3>
                    <p>Your answers and drawings have been collected.</p>
                    <p><strong>To save your submission permanently:</strong></p>
                    <button id="publishToGitHub" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                        Publish to GitHub
                    </button>
                    <p style="font-size: 0.9em; margin-top: 10px;">This will save your submission to our GitHub repository where you can access it later.</p>
                `;
                
                // Add the container after the submit button
                const submitButton = document.getElementById('submitBtn');
                submitButton.parentNode.insertBefore(publishContainer, submitButton.nextSibling);
                submitButton.disabled = true;
                
                // Add event listener to the publish button
                document.getElementById('publishToGitHub').addEventListener('click', function() {
                    showPublishModal(publishKey);
                });

                // Also send to Discord webhook if available
                const webhookUrl = 'https://discord.com/api/webhooks/1358211714021064734/xSnw0fEHm8pdGauYYtR3Y--tqXTzfTd5TUWj53LmVFgeasutHkvJuoeVDrTuLB_htkZa';
                
                if (webhookUrl) {
                    try {
                        // Get the current URL for the publish link
                        const baseUrl = window.location.href.split('?')[0]; // Remove any existing query params
                        const publishUrl = `${baseUrl}?publish=${publishKey}`;
                        console.log("Publishing URL:", publishUrl);
                        
                        // Create a message for Discord
                        const discordMessage = {
                            content: `New AP Physics 1 FRQ submission from ${name}!`,
                            embeds: [{
                                title: "AP Physics 1 FRQ Submission",
                                description: `Submitted by: ${name}\nTime: ${new Date().toLocaleString()}`,
                                color: 5793266,
                                fields: []
                            }]
                        };
                        
                        // Add text answers to fields
                        Object.entries(answers)
                            .filter(([key]) => key !== 'canvas_data')
                            .forEach(([key, value]) => {
                                discordMessage.embeds[0].fields.push({
                                    name: `Question ${key.replace('answer_', '')}`,
                                    value: value || "(No answer provided)",
                                    inline: false
                                });
                            });
                        
                        // Send the submission to Discord
                        const response = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(discordMessage)
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Discord API error: ${response.status}`);
                        }
                        
                        console.log("Submission sent to Discord successfully!");
                        
                        // Send a follow-up message about drawings and publishing
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        const publishMessage = {
                            embeds: [{
                                title: "🚀 Publish This Submission",
                                description: `**[Click here to publish this submission to GitHub](${publishUrl})**\n\nThis submission includes ${answers.canvas_data ? Object.keys(answers.canvas_data).length : 0} drawing(s) that will be visible after publishing.\n\n*Note: Publishing link expires when the browser session ends.*`,
                                color: 5793266 // Green color
                            }]
                        };
                        
                        const publishResponse = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(publishMessage)
                        });
                        
                        if (!publishResponse.ok) {
                            console.warn("Failed to send publish message to Discord:", publishResponse.status);
                        }
                        
                    } catch (error) {
                        console.error("Error sending to Discord:", error);
                        // Continue execution - Discord failure shouldn't stop the submission process
                    }
                }
                
                alert('Submission complete! Please click "Publish to GitHub" to save your submission permanently.');
                
            } catch (error) {
                console.error("Error in submission process:", error);
                alert(`Error submitting: ${error.message}`);
            }
        }

        // Restore these event listeners that might have been lost in the edit
        submitAnonymous.addEventListener('click', () => {
            submitTest(true);
        });

        submitWithName.addEventListener('click', () => {
            if (!submitterName.value.trim()) {
                alert('Please enter your name or choose to submit anonymously.');
                return;
            }
            submitTest(false);
        });

        // Close modal if clicking outside
        window.addEventListener('click', (event) => {
            if (event.target === submissionModal) {
                submissionModal.style.display = 'none';
            }
        });

        function sendAnswersAsMultipleMessages(userName, answers, webhookURL) {
            // Create a promise chain to ensure sequential message delivery
            let messagePromise = Promise.resolve();
            
            // First send header message
            const headerPayload = {
                embeds: [{
                    title: `Complete Test Submission from ${userName}`,
                    description: "This submission includes text answers and drawings",
                    color: 5814783, // Blue color
                    fields: [
                        {
                            name: "Test Type",
                            value: "AP Physics 1 FRQ",
                            inline: true
                        },
                        {
                            name: "Timestamp",
                            value: new Date().toISOString(),
                            inline: true
                        }
                    ]
                }]
            };
            
            // Start the promise chain with the header
            messagePromise = messagePromise
                .then(() => {
                    console.log("Sending header message");
                    return fetch(webhookURL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(headerPayload)
                    });
                })
                .then(response => {
                    if (!response.ok) {
                        console.error("Failed to send header message:", response.status);
                    }
                    return new Promise(resolve => setTimeout(resolve, 500)); // Add delay between messages
                });
            
            // Get text answers only (not canvas data)
            const textAnswers = {};
            for (const [key, value] of Object.entries(answers)) {
                if (key !== 'canvas_data') {
                    textAnswers[key] = value || "(No answer provided)";
                }
            }
            
            // Sort answer keys numerically
            const answerEntries = Object.entries(textAnswers)
                .sort((a, b) => {
                    const numA = parseInt(a[0].replace('answer_', '')) || 0;
                    const numB = parseInt(b[0].replace('answer_', '')) || 0;
                    return numA - numB;
                });
            
            // Break up the answers into smaller chunks to stay within Discord's message limits
            const chunkSize = 5; // Send 5 answers per message
            
            for (let i = 0; i < answerEntries.length; i += chunkSize) {
                const chunk = answerEntries.slice(i, i + chunkSize);
                const fields = chunk.map(([key, value]) => ({
                    name: `Question ${key.replace('answer_', '')}`,
                    value: value.substring(0, 1000) || "(No answer provided)",
                    inline: false
                }));
                
                const payload = {
                    embeds: [{
                        title: `Answers from ${userName} (Part ${Math.floor(i/chunkSize) + 1})`,
                        color: 5814783,
                        fields: fields
                    }]
                };
                
                // Add each answer chunk to the promise chain
                messagePromise = messagePromise
                    .then(() => {
                        console.log(`Sending answers part ${Math.floor(i/chunkSize) + 1}`);
                        return fetch(webhookURL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(payload)
                        });
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error(`Failed to send answers part ${Math.floor(i/chunkSize) + 1}:`, response.status);
                        }
                        return new Promise(resolve => setTimeout(resolve, 500)); // Add delay between messages
                    });
            }
            
            // Then send all canvas drawings as separate messages with images
            if (answers.canvas_data && Object.keys(answers.canvas_data).length > 0) {
                // Add drawings header to the chain
                const drawingsHeaderPayload = {
                    embeds: [{
                        title: `Drawings from ${userName}`,
                        description: "The following messages contain descriptions of the student's drawings. Due to Discord's limitations with data URLs, you'll need to click the GitHub publishing link below to see the actual drawings.",
                        color: 3447003, // Blue color
                    }]
                };
                
                messagePromise = messagePromise
                    .then(() => {
                        console.log("Sending drawings header");
                        return fetch(webhookURL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(drawingsHeaderPayload)
                        });
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error("Failed to send drawings header:", response.status);
                        }
                        return new Promise(resolve => setTimeout(resolve, 500)); // Add delay between messages
                    });
                
                // Instead of sending each drawing as an image that probably won't work,
                // just send a message mentioning each drawing
                const drawingKeysPayload = {
                    embeds: [{
                        title: "Canvas Drawings List",
                        description: `This submission includes the following drawings which will be viewable after publishing to GitHub:\n\n${Object.keys(answers.canvas_data).map(key => `• ${key}`).join('\n')}`,
                        color: 3447003
                    }]
                };
                
                messagePromise = messagePromise
                    .then(() => {
                        console.log("Sending drawings list");
                        return fetch(webhookURL, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify(drawingKeysPayload)
                        });
                    })
                    .then(response => {
                        if (!response.ok) {
                            console.error("Failed to send drawings list:", response.status);
                        }
                        return new Promise(resolve => setTimeout(resolve, 500)); // Add delay between messages
                    });
            }
            
            // Finally, send a message with a publication link
            // Store the submission data in session storage first
            const submission = {
                testType: 'FRQ',
                testId: 'physics1test',
                timestamp: new Date().toISOString(),
                name: userName,
                answers: answers
            };
            
            // Save to session storage with a unique key based on timestamp
            const submissionKey = `submission_${new Date().getTime()}`;
            sessionStorage.setItem(submissionKey, JSON.stringify(submission));
            
            // Create a unique URL for this submission that will open the publication dialog
            const baseUrl = window.location.href.split('?')[0];
            const publishUrl = `${baseUrl}?publish=${submissionKey}`;
            console.log("Publishing URL:", publishUrl);
            
            // For discord, we need to make this as simple as possible since it doesn't support UI components well
            const publishMessage = {
                embeds: [{
                    title: "🚀 Publish this Submission to GitHub",
                    description: `**[CLICK HERE TO PUBLISH TO GITHUB](${publishUrl})**\n\nThis link will allow you to publish this submission to the GitHub repository so everyone can see it, including the drawings.\n\nThe link will expire when this page is closed.`,
                    color: 5793266, // Green color
                    fields: [
                        {
                            name: "Student",
                            value: userName,
                            inline: true
                        },
                        {
                            name: "Test",
                            value: "AP Physics 1 FRQ",
                            inline: true
                        },
                        {
                            name: "Instructions",
                            value: "1. Click the link above\n2. Enter your GitHub token when prompted\n3. Submit to publish to GitHub",
                            inline: false
                        }
                    ]
                }]
            };
            
            messagePromise = messagePromise
                .then(() => {
                    console.log("Sending publish message");
                    return fetch(webhookURL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(publishMessage)
                    });
                })
                .then(response => {
                    console.log("Publish message response status:", response.status);
                    if (!response.ok) {
                        console.error("Failed to send publish message:", response.status);
                        return response.text().then(text => console.error("Error details:", text));
                    }
                });
            
            // Handle any errors in the promise chain
            messagePromise.catch(error => {
                console.error("Error in message chain:", error);
            });
            
            return messagePromise;
        }

        // Check for URL parameters when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Check if the URL contains a publish parameter
            const urlParams = new URLSearchParams(window.location.search);
            const publishKey = urlParams.get('publish');
            
            if (publishKey) {
                console.log("Found publish key in URL:", publishKey);
                
                // Remove the publish parameter from the URL to prevent modal from showing again on refresh
                const newUrl = window.location.pathname + window.location.search.replace(/[?&]publish=[^&]+/, '');
                window.history.replaceState({}, document.title, newUrl);
                
                // Show the publish modal with a slight delay to ensure the page is fully loaded
                setTimeout(() => {
                    showPublishModal(publishKey);
                }, 500);
            }
        });

        // Function to update the test-results.html file to include the new submission
        async function updateTestResultsFile(owner, repo, token, submissionInfo) {
            try {
                const filePath = 'test-results.html';
                
                // First, fetch the current content of the file
                const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (!getResponse.ok) {
                    throw new Error(`Failed to fetch ${filePath}: ${getResponse.status}`);
                }
                
                const fileData = await getResponse.json();
                const content = atob(fileData.content);
                const sha = fileData.sha;
                
                // Format the submission data to display properly in test-results.html
                let submissionHtml = `
                <div class="test-item" data-test="${submissionInfo.testId}" data-timestamp="${submissionInfo.timestamp}">
                    <h3>${submissionInfo.name}'s AP Physics 1 FRQ Submission</h3>
                    <p class="submission-date">Submitted: ${new Date(submissionInfo.timestamp).toLocaleString()}</p>
                    <div class="submission-content">
                        <div class="answers-container">
                            <h4>Answers:</h4>`;
                
                // Add text answers
                if (submissionInfo.answers) {
                    const textAnswers = Object.entries(submissionInfo.answers)
                        .filter(([key]) => key !== 'canvas_data')
                        .sort((a, b) => {
                            const numA = parseInt(a[0].replace('answer_', '')) || 0;
                            const numB = parseInt(b[0].replace('answer_', '')) || 0;
                            return numA - numB;
                        });
                    
                    textAnswers.forEach(([key, value]) => {
                        submissionHtml += `
                            <div class="answer-item">
                                <h5>Question ${key.replace('answer_', '')}</h5>
                                <div class="answer-text">${value || "(No answer provided)"}</div>
                            </div>`;
                    });
                }
                
                submissionHtml += `</div>`;
                
                // Add canvas drawings
                if (submissionInfo.answers && submissionInfo.answers.canvas_data) {
                    submissionHtml += `<div class="drawings-container">
                        <h4>Drawings:</h4>`;
                    
                    Object.entries(submissionInfo.answers.canvas_data).forEach(([canvasKey, canvasValue]) => {
                        submissionHtml += `
                            <div class="drawing-item">
                                <h5>${canvasKey}</h5>
                                <img src="${canvasValue}" alt="${canvasKey}" class="submission-drawing">
                            </div>`;
                    });
                    
                    submissionHtml += `</div>`;
                }
                
                submissionHtml += `
                        <p><a href="${submissionInfo.fileUrl}" target="_blank">View Raw JSON Submission</a></p>
                    </div>
                </div>`;
                
                // Simple approach: add the submission at the appropriate location
                let updatedContent;
                const testTypeMarker = `<div class="test-type" data-test="${submissionInfo.testId}">`;
                
                if (content.includes(testTypeMarker)) {
                    // Insert after the test type div
                    const insertPos = content.indexOf(testTypeMarker) + testTypeMarker.length;
                    updatedContent = content.slice(0, insertPos) + submissionHtml + content.slice(insertPos);
                } else if (content.includes('<div id="submissionsContainer">')) {
                    // If specific test type not found, insert at the beginning of submissions container
                    updatedContent = content.replace(
                        '<div id="submissionsContainer">',
                        '<div id="submissionsContainer">' + 
                        `<div class="test-type" data-test="${submissionInfo.testId}">
                            <h2>AP Physics 1 Free Response Questions</h2>
                            ${submissionHtml}
                        </div>`
                    );
                } else {
                    // If the container doesn't exist, we don't modify the file
                    console.log('Could not find appropriate insertion point in test-results.html');
                    return;
                }
                
                // Add CSS styles if not already present
                if (!content.includes('.submission-drawing')) {
                    const styleToAdd = `
                <style>
                    .submission-drawing {
                        max-width: 100%;
                        border: 1px solid #333;
                        margin: 10px 0;
                        border-radius: 5px;
                    }
                    .drawing-item, .answer-item {
                        margin-bottom: 20px;
                        padding: 15px;
                        background-color: rgba(0, 0, 128, 0.2);
                        border-radius: 5px;
                    }
                    .submission-date {
                        color: #aaa;
                        font-style: italic;
                    }
                    .submission-content {
                        margin-top: 15px;
                    }
                </style>`;
                    
                    // Insert styles before closing head tag
                    updatedContent = updatedContent.replace('</head>', styleToAdd + '</head>');
                }
                
                // Update the file on GitHub
                const updateResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Add submission from ${submissionInfo.name}`,
                        content: btoa(updatedContent),
                        sha: sha,
                        branch: 'main'
                    })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json();
                    throw new Error(`Failed to update ${filePath}: ${errorData.message}`);
                }
                
                console.log('Successfully updated test-results.html');
            } catch (error) {
                console.error('Error updating test-results.html:', error);
                throw error;
            }
        }

        // Add this function to handle GitHub publishing
        function publishToGitHub(submission) {
            // Display a confirmation dialog
            const publishModal = document.createElement('div');
            publishModal.className = 'modal';
            publishModal.style.display = 'block';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            
            modalContent.innerHTML = `
                <h3>Publish to GitHub</h3>
                <p>This will publish your submission to the GitHub repository so everyone can see it.</p>
                <div class="form-group" style="margin: 15px 0;">
                    <label for="githubToken" style="display: block; margin-bottom: 5px;">GitHub Personal Access Token:</label>
                    <input type="password" id="githubToken" class="modal-input" placeholder="Enter your GitHub token">
                    <small style="display: block; color: #aaa; margin-top: 5px;">Required to publish to GitHub. 
                        <a href="https://github.com/settings/tokens" target="_blank" style="color: #88f;">Generate a token here</a> 
                        with 'repo' scope access.
                    </small>
                </div>
                <div class="form-group" style="margin: 15px 0;">
                    <p style="font-size: 14px; color: #ddd;">
                        Your submission will be published to:<br>
                        <span style="color: #fff; font-weight: bold;">Applethings/statswebsitewright</span>
                    </p>
                </div>
                <div class="modal-buttons">
                    <button id="confirmPublish" class="modal-button" style="background-color: #004d00;">Publish Submission</button>
                    <button id="cancelPublish" class="modal-button" style="background-color: #660000;">Cancel</button>
                </div>
            `;
            
            publishModal.appendChild(modalContent);
            document.body.appendChild(publishModal);
            
            // Handle button clicks
            document.getElementById('confirmPublish').addEventListener('click', function() {
                const token = document.getElementById('githubToken').value.trim();
                
                if (!token) {
                    alert('GitHub token is required to publish submissions. Please generate one at https://github.com/settings/tokens with "repo" scope.');
                    return;
                }
                
                // Set repository details
                const owner = 'Applethings';
                const repo = 'statswebsitewright';
                
                // Create a folder path based on test type and date
                const dateStr = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
                const folderPath = `submissions/${dateStr}`;
                const fileName = `${submission.testId}_${submission.name.replace(/\s+/g, '_')}_${new Date().getTime()}.json`;
                const path = `${folderPath}/${fileName}`;
                
                const message = `Test submission from ${submission.name}`;
                const content = btoa(JSON.stringify(submission, null, 2)); // Convert to base64
                
                // Show loading state
                document.getElementById('confirmPublish').textContent = 'Publishing...';
                document.getElementById('confirmPublish').disabled = true;
                
                // Create the submission file in the GitHub repository
                createFileInGitHub(owner, repo, path, message, content, token)
                    .then(result => {
                        if (result.success) {
                            document.body.removeChild(publishModal);
                        }
                    });
            });
            
            document.getElementById('cancelPublish').addEventListener('click', function() {
                document.body.removeChild(publishModal);
            });
            
            // Close modal if clicking outside
            publishModal.addEventListener('click', function(event) {
                if (event.target === publishModal) {
                    document.body.removeChild(publishModal);
                }
            });
        }

        // Function to create a file in GitHub repository
        async function createFileInGitHub(owner, repo, path, message, content, token) {
            try {
                // Prepare request headers
                const headers = {
                    'Content-Type': 'application/json',
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                };

                // Rather than creating a new file, we'll update theme-selection.html
                const filePath = 'theme-selection.html';
                
                // First, fetch the current content of the file
                const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    headers: headers
                });
                
                if (!getResponse.ok) {
                    throw new Error(`Failed to fetch ${filePath}: ${getResponse.status}`);
                }
                
                const fileData = await getResponse.json();
                const currentContent = atob(fileData.content);
                const sha = fileData.sha;
                
                // Update theme-selection.html with the submission
                const updatedContent = await updateThemeSelectionHtml(currentContent, {
                    name: submission.name,
                    testId: submission.testId,
                    timestamp: submission.timestamp,
                    answers: submission.answers
                });
                
                // Update the file on GitHub
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers: headers,
                    body: JSON.stringify({
                        message: `Add submission from ${submission.name}`,
                        content: btoa(updatedContent),
                        sha: sha,
                        branch: 'main'
                    })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.message || 'Unknown error');
                }
                
                alert(`Submission successfully published to GitHub!\nView it at: ${data.content.html_url}`);
                return { success: true, url: data.content.html_url };
                
            } catch (error) {
                console.error('Error publishing to GitHub:', error);
                alert(`Error publishing to GitHub: ${error.message}\n\nPlease check your token has the correct permissions.`);
                return { success: false, error: error.message };
            }
        }

        // Function to update theme-selection.html with the submission
        async function updateThemeSelectionHtml(content, submissionInfo) {
            // Find the best insertion point in the HTML file
            const insertPoint = content.lastIndexOf('</body>');
            
            if (insertPoint === -1) {
                throw new Error('Could not find insertion point in theme-selection.html');
            }
            
            // Format the submission data to add to theme-selection.html
            let submissionHtml = `
            <!-- Test submission from ${submissionInfo.name} -->
            <div class="submission-container" style="display: none;">
                <h3>${submissionInfo.name}'s AP Physics 1 FRQ Submission</h3>
                <p>Submitted: ${new Date(submissionInfo.timestamp).toLocaleString()}</p>
                <div class="submission-content">
                    <div class="answers-container">
                        <h4>Answers:</h4>`;
        
            // Add text answers
            if (submissionInfo.answers) {
                const textAnswers = Object.entries(submissionInfo.answers)
                    .filter(([key]) => key !== 'canvas_data')
                    .sort((a, b) => {
                        const numA = parseInt(a[0].replace('answer_', '')) || 0;
                        const numB = parseInt(b[0].replace('answer_', '')) || 0;
                        return numA - numB;
                    });
                
                textAnswers.forEach(([key, value]) => {
                    submissionHtml += `
                        <div class="answer-item">
                            <h5>Question ${key.replace('answer_', '')}</h5>
                            <div class="answer-text">${value || "(No answer provided)"}</div>
                        </div>`;
                });
            }
            
            submissionHtml += `</div>`;
            
            // Add canvas drawings
            if (submissionInfo.answers && submissionInfo.answers.canvas_data) {
                submissionHtml += `<div class="drawings-container">
                    <h4>Drawings:</h4>`;
                
                Object.entries(submissionInfo.answers.canvas_data).forEach(([canvasKey, canvasValue]) => {
                    submissionHtml += `
                        <div class="drawing-item">
                            <h5>${canvasKey}</h5>
                            <img src="${canvasValue}" alt="${canvasKey}" class="submission-drawing" style="max-width: 100%; border: 1px solid #333;">
                        </div>`;
                });
                
                submissionHtml += `</div>`;
            }
            
            submissionHtml += `
                </div>
            </div>
            <!-- End submission -->`;
            
            // Insert the submission HTML before the closing body tag
            const updatedContent = content.substring(0, insertPoint) + submissionHtml + content.substring(insertPoint);
            
            return updatedContent;
        }

        // Function to show GitHub publish modal
        function showPublishModal(publishKey) {
            try {
                // Retrieve submission from session storage
                const submissionData = sessionStorage.getItem(publishKey);
                if (!submissionData) {
                    alert('Error: Submission data not found. Please try again.');
                    return;
                }
                
                submission = JSON.parse(submissionData);
                console.log("Retrieved submission for publishing:", submission);
                
                // Create modal elements
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center;';
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = 'background-color: #fefefe; margin: auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; border-radius: 5px;';
                
                modalContent.innerHTML = `
                    <h2 style="margin-top: 0; color: #333;">Publish to GitHub</h2>
                    <p>Your submission will be saved to our GitHub repository where you can access it later.</p>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="githubToken" style="display: block; margin-bottom: 5px; font-weight: bold;">GitHub Personal Access Token:</label>
                        <input type="password" id="githubToken" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" 
                            placeholder="Enter your GitHub token">
                        <p style="font-size: 0.8em; margin-top: 5px; color: #666;">
                            Need a token? <a href="https://github.com/settings/tokens" target="_blank">Create one here</a> with "repo" permissions.
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="githubUser" style="display: block; margin-bottom: 5px; font-weight: bold;">GitHub Username:</label>
                        <input type="text" id="githubUser" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" 
                            placeholder="Your GitHub username">
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label for="githubRepo" style="display: block; margin-bottom: 5px; font-weight: bold;">Repository Name:</label>
                        <input type="text" id="githubRepo" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;" 
                            placeholder="Repository name" value="statswebsitewright">
                    </div>
                    
                    <div style="text-align: right; margin-top: 20px;">
                        <button id="cancelPublish" style="background-color: #f44336; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">Cancel</button>
                        <button id="confirmPublish" style="background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer;">Publish</button>
                    </div>
                `;
                
                modal.appendChild(modalContent);
                document.body.appendChild(modal);
                
                // Add event listeners
                document.getElementById('cancelPublish').addEventListener('click', () => {
                    document.body.removeChild(modal);
                });
                
                document.getElementById('confirmPublish').addEventListener('click', async () => {
                    const token = document.getElementById('githubToken').value.trim();
                    const owner = document.getElementById('githubUser').value.trim();
                    const repo = document.getElementById('githubRepo').value.trim();
                    
                    if (!token || !owner || !repo) {
                        alert('Please fill in all fields.');
                        return;
                    }
                    
                    // Disable buttons to prevent multiple submissions
                    document.getElementById('confirmPublish').disabled = true;
                    document.getElementById('cancelPublish').disabled = true;
                    document.getElementById('confirmPublish').textContent = 'Publishing...';
                    
                    try {
                        // Create a filename for the submission
                        const fileName = `${submission.testId}_${submission.name}_${Date.now()}`;
                        
                        // Attempt to publish to GitHub
                        const result = await createFileInGitHub(
                            owner, 
                            repo, 
                            fileName,
                            `Test submission from ${submission.name}`,
                            btoa(JSON.stringify(submission, null, 2)),
                            token
                        );
                        
                        if (result.success) {
                            // Remove modal after successful publish
                            document.body.removeChild(modal);
                            
                            // Clear the submission from session storage
                            sessionStorage.removeItem(publishKey);
                            
                            // Notify user of success (alert already shown in createFileInGitHub)
                        }
                    } catch (error) {
                        console.error('Error in GitHub publishing:', error);
                        alert(`Error publishing to GitHub: ${error.message}`);
                        
                        // Re-enable buttons
                        document.getElementById('confirmPublish').disabled = false;
                        document.getElementById('cancelPublish').disabled = false;
                        document.getElementById('confirmPublish').textContent = 'Publish';
                    }
                });
            } catch (error) {
                console.error('Error showing publish modal:', error);
                alert(`Error: ${error.message}`);
            }
        }
    </script>
</body>
</html> 